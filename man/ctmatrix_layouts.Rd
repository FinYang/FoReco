% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/matrix_layout.R
\name{as_ctmatrix}
\alias{as_ctmatrix}
\alias{as_hstack_ctlayout}
\title{Convert between horizon-stacked and cross-temporal layouts}
\usage{
as_ctmatrix(hmat, agg_order, n, row_names = NULL)

as_hstack_ctlayout(ctmat, agg_order)
}
\arguments{
\item{hmat}{A \eqn{h \times n(k^\ast+m)} numeric matrix in \emph{horizon-stacked} layout
(cross-temporal version).}

\item{agg_order}{Highest available sampling frequency per seasonal cycle
(max. order of temporal aggregation, \eqn{m}), or a vector representing a
subset of \eqn{p} factors of \eqn{m}.}

\item{n}{Cross-sectional number of variables.}

\item{row_names}{Optional character vector of length \code{n} with row names
for the \emph{cross-temporal} output of \code{as_ctmatrix()}.
If \code{NULL} (\emph{default}) no custom names are assigned.}

\item{ctmat}{A \eqn{n \times h(k^\ast+m)} numeric matrix in \emph{cross-temporal} layout.}
}
\value{
\link{as_ctmatrix} returns a \eqn{n \times h(k^\ast+m)} numeric
matrix in \emph{cross-temporal} layout.

\link{as_hstack_ctlayout} returns a \eqn{h \times n(k^\ast+m)} numeric
matrix in \emph{horizon-stacked} layout (cross-temporal version).
}
\description{
These functions convert matrix between the two canonical layouts used in
cross-temporal reconciliation.
Let \eqn{m} be the maximum temporal aggregation order and \eqn{k^\ast} the sum
of a subset of the \eqn{(p-1)} proper factors of \eqn{m} (excluding \eqn{m});
let \eqn{h} be the forecast horizon for the lowest frequency series (e.g.,
most aggregated temporal forecast horizon) and \eqn{n} the number of variables:
\itemize{
\item \emph{Horizon-stacked layout (cross-temporal version)}: a
\eqn{h \times n(k^\ast + m)} matrix where rows are the most aggregated temporal
forecast horizons, and the values in each row are ordered from the lowest frequency
(most temporally aggregated) to the highest frequency grouped by variable.
\item \emph{Cross-temporal layout}: a \eqn{n \times h(k^\ast + m)} matrix where
rows are variables, and horizons for each temporal block appear consecutively.
rows are variables, and the values in each row are ordered from the lowest frequency
(most temporally aggregated) to the highest frequency.
}
Then, \link{as_ctmatrix} converts a \eqn{(h \times n(k^\ast+m))}
horizon-stacked to a \eqn{(n \times h(k^\ast+m))} cross-temporal matrix;
\link{as_hstack_ctlayout} performs the inverse transform.
}
\examples{
h <- 2   # horizons
n <- 3   # variables
m <- 4   # temporal aggregation order
kt <- tetools(m)$dim["kt"]

# Build a horizon-stacked matrix: h rows, n * k_t columns
input_ct <- matrix(seq_len(h * n * kt), nrow = n, byrow = TRUE)

hmat <- as_hstack_ctlayout(input_ct, agg_order = m)
ctmat <- as_ctmatrix(hmat, agg_order = m, n = n)
# all.equal(ctmat, input_ct, check.attributes = FALSE)

}
\seealso{
Utilities:
\code{\link{FoReco2matrix}()},
\code{\link{aggts}()},
\code{\link{as_tevector}()},
\code{\link{balance_hierarchy}()},
\code{\link{commat}()},
\code{\link{csprojmat}()},
\code{\link{cstools}()},
\code{\link{ctprojmat}()},
\code{\link{cttools}()},
\code{\link{df2aggmat}()},
\code{\link{lcmat}()},
\code{\link{recoinfo}()},
\code{\link{res2matrix}()},
\code{\link{set_bounds}()},
\code{\link{shrink_estim}()},
\code{\link{shrink_oasd}()},
\code{\link{teprojmat}()},
\code{\link{tetools}()},
\code{\link{unbalance_hierarchy}()}
}
\concept{Utilities}
