% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/matrix_layout.R
\name{as_tevector}
\alias{as_tevector}
\alias{as_hstack_telayout}
\title{Convert between horizon-stacked and temporal layouts}
\usage{
as_tevector(hmat, agg_order)

as_hstack_telayout(tevec, agg_order)
}
\arguments{
\item{hmat}{A \eqn{h \times (k^\ast+m)} numeric matrix in \emph{horizon-stacked} layout
(temporal version).}

\item{agg_order}{Highest available sampling frequency per seasonal cycle
(max. order of temporal aggregation, \eqn{m}), or a vector representing a
subset of \eqn{p} factors of \eqn{m}.}

\item{tevec}{A (\eqn{h(k^\ast + m) \times 1}) numeric vector in \emph{temporal} layout.}
}
\value{
\link{as_tevector} returns a (\eqn{h(k^\ast + m) \times 1}) numeric vector
in \emph{temporal} layout.

\link{as_hstack_telayout} returns a \eqn{h \times (k^\ast+m)} numeric
matrix in \emph{horizon-stacked} layout (temporal version).
}
\description{
These functions convert matrix between the two canonical layouts used in
temporal reconciliation.
Let \eqn{m} be the maximum temporal aggregation order and \eqn{k^\ast} the sum
of a subset of the \eqn{(p-1)} proper factors of \eqn{m} (excluding \eqn{m});
let \eqn{h} be the forecast horizon for the lowest frequency series (e.g.,
most aggregated temporal forecast horizon):
\itemize{
\item \emph{Horizon-stacked layout (temporal version)}: a
\eqn{h \times (k^\ast + m)} matrix where rows are the most aggregated temporal
forecast horizons, and the values in each row are ordered from the lowest frequency
(most temporally aggregated) to the highest frequency.
\item \emph{Temporal layout}: a (\eqn{h(k^\ast + m) \times 1}) numeric vector where
values are ordered from the lowest frequency (most temporally aggregated) to the
highest frequency.
}
Then, \link{as_tevector} converts a \eqn{(h \times (k^\ast+m))}
horizon-stacked matrix to a (\eqn{h(k^\ast + m) \times 1}) temporal vector;
\link{as_hstack_telayout} performs the inverse transform.
}
\examples{
h <- 2   # horizons
m <- 4   # temporal aggregation order
kt <- tetools(m)$dim["kt"]

# Build a horizon-stacked matrix: h rows, n * k_t columns
input_te <- seq_len(h * kt)

hmat <- as_hstack_telayout(input_te, agg_order = m)
tevec <- as_tevector(hmat, agg_order = m)
# all.equal(tevec, input_te, check.attributes = FALSE)

}
\seealso{
Utilities:
\code{\link{FoReco2matrix}()},
\code{\link{aggts}()},
\code{\link{as_ctmatrix}()},
\code{\link{balance_hierarchy}()},
\code{\link{commat}()},
\code{\link{csprojmat}()},
\code{\link{cstools}()},
\code{\link{ctprojmat}()},
\code{\link{cttools}()},
\code{\link{df2aggmat}()},
\code{\link{lcmat}()},
\code{\link{recoinfo}()},
\code{\link{res2matrix}()},
\code{\link{set_bounds}()},
\code{\link{shrink_estim}()},
\code{\link{shrink_oasd}()},
\code{\link{teprojmat}()},
\code{\link{tetools}()},
\code{\link{unbalance_hierarchy}()}
}
\concept{Utilities}
