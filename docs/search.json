[{"path":[]},{"path":"https://danigiro.github.io/FoReco/CODE_OF_CONDUCT.html","id":"our-pledge","dir":"","previous_headings":"","what":"Our Pledge","title":"Contributor Covenant Code of Conduct","text":"interest fostering open welcoming environment, contributors maintainers pledge making participation project community harassment-free experience everyone, regardless age, body size, disability, ethnicity, sex characteristics, gender identity expression, level experience, education, socio-economic status, nationality, personal appearance, race, religion, sexual identity orientation.","code":""},{"path":"https://danigiro.github.io/FoReco/CODE_OF_CONDUCT.html","id":"our-standards","dir":"","previous_headings":"","what":"Our Standards","title":"Contributor Covenant Code of Conduct","text":"Examples behavior contributes creating positive environment include: Using welcoming inclusive language respectful differing viewpoints experiences Gracefully accepting constructive criticism Focusing best community Showing empathy towards community members Examples unacceptable behavior participants include: use sexualized language imagery unwelcome sexual attention advances Trolling, insulting/derogatory comments, personal political attacks Public private harassment Publishing others’ private information, physical electronic address, without explicit permission conduct reasonably considered inappropriate professional setting","code":""},{"path":"https://danigiro.github.io/FoReco/CODE_OF_CONDUCT.html","id":"our-responsibilities","dir":"","previous_headings":"","what":"Our Responsibilities","title":"Contributor Covenant Code of Conduct","text":"Project maintainers responsible clarifying standards acceptable behavior expected take appropriate fair corrective action response instances unacceptable behavior. Project maintainers right responsibility remove, edit, reject comments, commits, code, wiki edits, issues, contributions aligned Code Conduct, ban temporarily permanently contributor behaviors deem inappropriate, threatening, offensive, harmful.","code":""},{"path":"https://danigiro.github.io/FoReco/CODE_OF_CONDUCT.html","id":"scope","dir":"","previous_headings":"","what":"Scope","title":"Contributor Covenant Code of Conduct","text":"Code Conduct applies within project spaces public spaces individual representing project community. Examples representing project community include using official project e-mail address, posting via official social media account, acting appointed representative online offline event. Representation project may defined clarified project maintainers.","code":""},{"path":"https://danigiro.github.io/FoReco/CODE_OF_CONDUCT.html","id":"enforcement","dir":"","previous_headings":"","what":"Enforcement","title":"Contributor Covenant Code of Conduct","text":"Instances abusive, harassing, otherwise unacceptable behavior may reported contacting project team daniele.girolimetto@phd.unipd.. complaints reviewed investigated result response deemed necessary appropriate circumstances. project team obligated maintain confidentiality regard reporter incident. details specific enforcement policies may posted separately. Project maintainers follow enforce Code Conduct good faith may face temporary permanent repercussions determined members project’s leadership.","code":""},{"path":"https://danigiro.github.io/FoReco/CODE_OF_CONDUCT.html","id":"attribution","dir":"","previous_headings":"","what":"Attribution","title":"Contributor Covenant Code of Conduct","text":"Code Conduct adapted Contributor Covenant, version 1.4, available https://www.contributor-covenant.org/version/1/4/code--conduct.html answers common questions code conduct, see https://www.contributor-covenant.org/faq","code":""},{"path":"https://danigiro.github.io/FoReco/LICENSE.html","id":null,"dir":"","previous_headings":"","what":"GNU General Public License","title":"GNU General Public License","text":"Version 3, 29 June 2007Copyright © 2007 Free Software Foundation, Inc. <http://fsf.org/> Everyone permitted copy distribute verbatim copies license document, changing allowed.","code":""},{"path":"https://danigiro.github.io/FoReco/LICENSE.html","id":"preamble","dir":"","previous_headings":"","what":"Preamble","title":"GNU General Public License","text":"GNU General Public License free, copyleft license software kinds works. licenses software practical works designed take away freedom share change works. contrast, GNU General Public License intended guarantee freedom share change versions program–make sure remains free software users. , Free Software Foundation, use GNU General Public License software; applies also work released way authors. can apply programs, . speak free software, referring freedom, price. General Public Licenses designed make sure freedom distribute copies free software (charge wish), receive source code can get want , can change software use pieces new free programs, know can things. protect rights, need prevent others denying rights asking surrender rights. Therefore, certain responsibilities distribute copies software, modify : responsibilities respect freedom others. example, distribute copies program, whether gratis fee, must pass recipients freedoms received. must make sure , , receive can get source code. must show terms know rights. Developers use GNU GPL protect rights two steps: (1) assert copyright software, (2) offer License giving legal permission copy, distribute /modify . developers’ authors’ protection, GPL clearly explains warranty free software. users’ authors’ sake, GPL requires modified versions marked changed, problems attributed erroneously authors previous versions. devices designed deny users access install run modified versions software inside , although manufacturer can . fundamentally incompatible aim protecting users’ freedom change software. systematic pattern abuse occurs area products individuals use, precisely unacceptable. Therefore, designed version GPL prohibit practice products. problems arise substantially domains, stand ready extend provision domains future versions GPL, needed protect freedom users. Finally, every program threatened constantly software patents. States allow patents restrict development use software general-purpose computers, , wish avoid special danger patents applied free program make effectively proprietary. prevent , GPL assures patents used render program non-free. precise terms conditions copying, distribution modification follow.","code":""},{"path":[]},{"path":"https://danigiro.github.io/FoReco/LICENSE.html","id":"id_0-definitions","dir":"","previous_headings":"TERMS AND CONDITIONS","what":"0. Definitions","title":"GNU General Public License","text":"“License” refers version 3 GNU General Public License. “Copyright” also means copyright-like laws apply kinds works, semiconductor masks. “Program” refers copyrightable work licensed License. licensee addressed “”. “Licensees” “recipients” may individuals organizations. “modify” work means copy adapt part work fashion requiring copyright permission, making exact copy. resulting work called “modified version” earlier work work “based ” earlier work. “covered work” means either unmodified Program work based Program. “propagate” work means anything , without permission, make directly secondarily liable infringement applicable copyright law, except executing computer modifying private copy. Propagation includes copying, distribution (without modification), making available public, countries activities well. “convey” work means kind propagation enables parties make receive copies. Mere interaction user computer network, transfer copy, conveying. interactive user interface displays “Appropriate Legal Notices” extent includes convenient prominently visible feature (1) displays appropriate copyright notice, (2) tells user warranty work (except extent warranties provided), licensees may convey work License, view copy License. interface presents list user commands options, menu, prominent item list meets criterion.","code":""},{"path":"https://danigiro.github.io/FoReco/LICENSE.html","id":"id_1-source-code","dir":"","previous_headings":"TERMS AND CONDITIONS","what":"1. Source Code","title":"GNU General Public License","text":"“source code” work means preferred form work making modifications . “Object code” means non-source form work. “Standard Interface” means interface either official standard defined recognized standards body, , case interfaces specified particular programming language, one widely used among developers working language. “System Libraries” executable work include anything, work whole, () included normal form packaging Major Component, part Major Component, (b) serves enable use work Major Component, implement Standard Interface implementation available public source code form. “Major Component”, context, means major essential component (kernel, window system, ) specific operating system () executable work runs, compiler used produce work, object code interpreter used run . “Corresponding Source” work object code form means source code needed generate, install, (executable work) run object code modify work, including scripts control activities. However, include work’s System Libraries, general-purpose tools generally available free programs used unmodified performing activities part work. example, Corresponding Source includes interface definition files associated source files work, source code shared libraries dynamically linked subprograms work specifically designed require, intimate data communication control flow subprograms parts work. Corresponding Source need include anything users can regenerate automatically parts Corresponding Source. Corresponding Source work source code form work.","code":""},{"path":"https://danigiro.github.io/FoReco/LICENSE.html","id":"id_2-basic-permissions","dir":"","previous_headings":"TERMS AND CONDITIONS","what":"2. Basic Permissions","title":"GNU General Public License","text":"rights granted License granted term copyright Program, irrevocable provided stated conditions met. License explicitly affirms unlimited permission run unmodified Program. output running covered work covered License output, given content, constitutes covered work. License acknowledges rights fair use equivalent, provided copyright law. may make, run propagate covered works convey, without conditions long license otherwise remains force. may convey covered works others sole purpose make modifications exclusively , provide facilities running works, provided comply terms License conveying material control copyright. thus making running covered works must exclusively behalf, direction control, terms prohibit making copies copyrighted material outside relationship . Conveying circumstances permitted solely conditions stated . Sublicensing allowed; section 10 makes unnecessary.","code":""},{"path":"https://danigiro.github.io/FoReco/LICENSE.html","id":"id_3-protecting-users-legal-rights-from-anti-circumvention-law","dir":"","previous_headings":"TERMS AND CONDITIONS","what":"3. Protecting Users’ Legal Rights From Anti-Circumvention Law","title":"GNU General Public License","text":"covered work shall deemed part effective technological measure applicable law fulfilling obligations article 11 WIPO copyright treaty adopted 20 December 1996, similar laws prohibiting restricting circumvention measures. convey covered work, waive legal power forbid circumvention technological measures extent circumvention effected exercising rights License respect covered work, disclaim intention limit operation modification work means enforcing, work’s users, third parties’ legal rights forbid circumvention technological measures.","code":""},{"path":"https://danigiro.github.io/FoReco/LICENSE.html","id":"id_4-conveying-verbatim-copies","dir":"","previous_headings":"TERMS AND CONDITIONS","what":"4. Conveying Verbatim Copies","title":"GNU General Public License","text":"may convey verbatim copies Program’s source code receive , medium, provided conspicuously appropriately publish copy appropriate copyright notice; keep intact notices stating License non-permissive terms added accord section 7 apply code; keep intact notices absence warranty; give recipients copy License along Program. may charge price price copy convey, may offer support warranty protection fee.","code":""},{"path":"https://danigiro.github.io/FoReco/LICENSE.html","id":"id_5-conveying-modified-source-versions","dir":"","previous_headings":"TERMS AND CONDITIONS","what":"5. Conveying Modified Source Versions","title":"GNU General Public License","text":"may convey work based Program, modifications produce Program, form source code terms section 4, provided also meet conditions: ) work must carry prominent notices stating modified , giving relevant date. b) work must carry prominent notices stating released License conditions added section 7. requirement modifies requirement section 4 “keep intact notices”. c) must license entire work, whole, License anyone comes possession copy. License therefore apply, along applicable section 7 additional terms, whole work, parts, regardless packaged. License gives permission license work way, invalidate permission separately received . d) work interactive user interfaces, must display Appropriate Legal Notices; however, Program interactive interfaces display Appropriate Legal Notices, work need make . compilation covered work separate independent works, nature extensions covered work, combined form larger program, volume storage distribution medium, called “aggregate” compilation resulting copyright used limit access legal rights compilation’s users beyond individual works permit. Inclusion covered work aggregate cause License apply parts aggregate.","code":""},{"path":"https://danigiro.github.io/FoReco/LICENSE.html","id":"id_6-conveying-non-source-forms","dir":"","previous_headings":"TERMS AND CONDITIONS","what":"6. Conveying Non-Source Forms","title":"GNU General Public License","text":"may convey covered work object code form terms sections 4 5, provided also convey machine-readable Corresponding Source terms License, one ways: ) Convey object code , embodied , physical product (including physical distribution medium), accompanied Corresponding Source fixed durable physical medium customarily used software interchange. b) Convey object code , embodied , physical product (including physical distribution medium), accompanied written offer, valid least three years valid long offer spare parts customer support product model, give anyone possesses object code either (1) copy Corresponding Source software product covered License, durable physical medium customarily used software interchange, price reasonable cost physically performing conveying source, (2) access copy Corresponding Source network server charge. c) Convey individual copies object code copy written offer provide Corresponding Source. alternative allowed occasionally noncommercially, received object code offer, accord subsection 6b. d) Convey object code offering access designated place (gratis charge), offer equivalent access Corresponding Source way place charge. need require recipients copy Corresponding Source along object code. place copy object code network server, Corresponding Source may different server (operated third party) supports equivalent copying facilities, provided maintain clear directions next object code saying find Corresponding Source. Regardless server hosts Corresponding Source, remain obligated ensure available long needed satisfy requirements. e) Convey object code using peer--peer transmission, provided inform peers object code Corresponding Source work offered general public charge subsection 6d. separable portion object code, whose source code excluded Corresponding Source System Library, need included conveying object code work. “User Product” either (1) “consumer product”, means tangible personal property normally used personal, family, household purposes, (2) anything designed sold incorporation dwelling. determining whether product consumer product, doubtful cases shall resolved favor coverage. particular product received particular user, “normally used” refers typical common use class product, regardless status particular user way particular user actually uses, expects expected use, product. product consumer product regardless whether product substantial commercial, industrial non-consumer uses, unless uses represent significant mode use product. “Installation Information” User Product means methods, procedures, authorization keys, information required install execute modified versions covered work User Product modified version Corresponding Source. information must suffice ensure continued functioning modified object code case prevented interfered solely modification made. convey object code work section , , specifically use , User Product, conveying occurs part transaction right possession use User Product transferred recipient perpetuity fixed term (regardless transaction characterized), Corresponding Source conveyed section must accompanied Installation Information. requirement apply neither third party retains ability install modified object code User Product (example, work installed ROM). requirement provide Installation Information include requirement continue provide support service, warranty, updates work modified installed recipient, User Product modified installed. Access network may denied modification materially adversely affects operation network violates rules protocols communication across network. Corresponding Source conveyed, Installation Information provided, accord section must format publicly documented (implementation available public source code form), must require special password key unpacking, reading copying.","code":""},{"path":"https://danigiro.github.io/FoReco/LICENSE.html","id":"id_7-additional-terms","dir":"","previous_headings":"TERMS AND CONDITIONS","what":"7. Additional Terms","title":"GNU General Public License","text":"“Additional permissions” terms supplement terms License making exceptions one conditions. Additional permissions applicable entire Program shall treated though included License, extent valid applicable law. additional permissions apply part Program, part may used separately permissions, entire Program remains governed License without regard additional permissions. convey copy covered work, may option remove additional permissions copy, part . (Additional permissions may written require removal certain cases modify work.) may place additional permissions material, added covered work, can give appropriate copyright permission. Notwithstanding provision License, material add covered work, may (authorized copyright holders material) supplement terms License terms: ) Disclaiming warranty limiting liability differently terms sections 15 16 License; b) Requiring preservation specified reasonable legal notices author attributions material Appropriate Legal Notices displayed works containing ; c) Prohibiting misrepresentation origin material, requiring modified versions material marked reasonable ways different original version; d) Limiting use publicity purposes names licensors authors material; e) Declining grant rights trademark law use trade names, trademarks, service marks; f) Requiring indemnification licensors authors material anyone conveys material (modified versions ) contractual assumptions liability recipient, liability contractual assumptions directly impose licensors authors. non-permissive additional terms considered “restrictions” within meaning section 10. Program received , part , contains notice stating governed License along term restriction, may remove term. license document contains restriction permits relicensing conveying License, may add covered work material governed terms license document, provided restriction survive relicensing conveying. add terms covered work accord section, must place, relevant source files, statement additional terms apply files, notice indicating find applicable terms. Additional terms, permissive non-permissive, may stated form separately written license, stated exceptions; requirements apply either way.","code":""},{"path":"https://danigiro.github.io/FoReco/LICENSE.html","id":"id_8-termination","dir":"","previous_headings":"TERMS AND CONDITIONS","what":"8. Termination","title":"GNU General Public License","text":"may propagate modify covered work except expressly provided License. attempt otherwise propagate modify void, automatically terminate rights License (including patent licenses granted third paragraph section 11). However, cease violation License, license particular copyright holder reinstated () provisionally, unless copyright holder explicitly finally terminates license, (b) permanently, copyright holder fails notify violation reasonable means prior 60 days cessation. Moreover, license particular copyright holder reinstated permanently copyright holder notifies violation reasonable means, first time received notice violation License (work) copyright holder, cure violation prior 30 days receipt notice. Termination rights section terminate licenses parties received copies rights License. rights terminated permanently reinstated, qualify receive new licenses material section 10.","code":""},{"path":"https://danigiro.github.io/FoReco/LICENSE.html","id":"id_9-acceptance-not-required-for-having-copies","dir":"","previous_headings":"TERMS AND CONDITIONS","what":"9. Acceptance Not Required for Having Copies","title":"GNU General Public License","text":"required accept License order receive run copy Program. Ancillary propagation covered work occurring solely consequence using peer--peer transmission receive copy likewise require acceptance. However, nothing License grants permission propagate modify covered work. actions infringe copyright accept License. Therefore, modifying propagating covered work, indicate acceptance License .","code":""},{"path":"https://danigiro.github.io/FoReco/LICENSE.html","id":"id_10-automatic-licensing-of-downstream-recipients","dir":"","previous_headings":"TERMS AND CONDITIONS","what":"10. Automatic Licensing of Downstream Recipients","title":"GNU General Public License","text":"time convey covered work, recipient automatically receives license original licensors, run, modify propagate work, subject License. responsible enforcing compliance third parties License. “entity transaction” transaction transferring control organization, substantially assets one, subdividing organization, merging organizations. propagation covered work results entity transaction, party transaction receives copy work also receives whatever licenses work party’s predecessor interest give previous paragraph, plus right possession Corresponding Source work predecessor interest, predecessor can get reasonable efforts. may impose restrictions exercise rights granted affirmed License. example, may impose license fee, royalty, charge exercise rights granted License, may initiate litigation (including cross-claim counterclaim lawsuit) alleging patent claim infringed making, using, selling, offering sale, importing Program portion .","code":""},{"path":"https://danigiro.github.io/FoReco/LICENSE.html","id":"id_11-patents","dir":"","previous_headings":"TERMS AND CONDITIONS","what":"11. Patents","title":"GNU General Public License","text":"“contributor” copyright holder authorizes use License Program work Program based. work thus licensed called contributor’s “contributor version”. contributor’s “essential patent claims” patent claims owned controlled contributor, whether already acquired hereafter acquired, infringed manner, permitted License, making, using, selling contributor version, include claims infringed consequence modification contributor version. purposes definition, “control” includes right grant patent sublicenses manner consistent requirements License. contributor grants non-exclusive, worldwide, royalty-free patent license contributor’s essential patent claims, make, use, sell, offer sale, import otherwise run, modify propagate contents contributor version. following three paragraphs, “patent license” express agreement commitment, however denominated, enforce patent (express permission practice patent covenant sue patent infringement). “grant” patent license party means make agreement commitment enforce patent party. convey covered work, knowingly relying patent license, Corresponding Source work available anyone copy, free charge terms License, publicly available network server readily accessible means, must either (1) cause Corresponding Source available, (2) arrange deprive benefit patent license particular work, (3) arrange, manner consistent requirements License, extend patent license downstream recipients. “Knowingly relying” means actual knowledge , patent license, conveying covered work country, recipient’s use covered work country, infringe one identifiable patents country reason believe valid. , pursuant connection single transaction arrangement, convey, propagate procuring conveyance , covered work, grant patent license parties receiving covered work authorizing use, propagate, modify convey specific copy covered work, patent license grant automatically extended recipients covered work works based . patent license “discriminatory” include within scope coverage, prohibits exercise , conditioned non-exercise one rights specifically granted License. may convey covered work party arrangement third party business distributing software, make payment third party based extent activity conveying work, third party grants, parties receive covered work , discriminatory patent license () connection copies covered work conveyed (copies made copies), (b) primarily connection specific products compilations contain covered work, unless entered arrangement, patent license granted, prior 28 March 2007. Nothing License shall construed excluding limiting implied license defenses infringement may otherwise available applicable patent law.","code":""},{"path":"https://danigiro.github.io/FoReco/LICENSE.html","id":"id_12-no-surrender-of-others-freedom","dir":"","previous_headings":"TERMS AND CONDITIONS","what":"12. No Surrender of Others’ Freedom","title":"GNU General Public License","text":"conditions imposed (whether court order, agreement otherwise) contradict conditions License, excuse conditions License. convey covered work satisfy simultaneously obligations License pertinent obligations, consequence may convey . example, agree terms obligate collect royalty conveying convey Program, way satisfy terms License refrain entirely conveying Program.","code":""},{"path":"https://danigiro.github.io/FoReco/LICENSE.html","id":"id_13-use-with-the-gnu-affero-general-public-license","dir":"","previous_headings":"TERMS AND CONDITIONS","what":"13. Use with the GNU Affero General Public License","title":"GNU General Public License","text":"Notwithstanding provision License, permission link combine covered work work licensed version 3 GNU Affero General Public License single combined work, convey resulting work. terms License continue apply part covered work, special requirements GNU Affero General Public License, section 13, concerning interaction network apply combination .","code":""},{"path":"https://danigiro.github.io/FoReco/LICENSE.html","id":"id_14-revised-versions-of-this-license","dir":"","previous_headings":"TERMS AND CONDITIONS","what":"14. Revised Versions of this License","title":"GNU General Public License","text":"Free Software Foundation may publish revised /new versions GNU General Public License time time. new versions similar spirit present version, may differ detail address new problems concerns. version given distinguishing version number. Program specifies certain numbered version GNU General Public License “later version” applies , option following terms conditions either numbered version later version published Free Software Foundation. Program specify version number GNU General Public License, may choose version ever published Free Software Foundation. Program specifies proxy can decide future versions GNU General Public License can used, proxy’s public statement acceptance version permanently authorizes choose version Program. Later license versions may give additional different permissions. However, additional obligations imposed author copyright holder result choosing follow later version.","code":""},{"path":"https://danigiro.github.io/FoReco/LICENSE.html","id":"id_15-disclaimer-of-warranty","dir":"","previous_headings":"TERMS AND CONDITIONS","what":"15. Disclaimer of Warranty","title":"GNU General Public License","text":"WARRANTY PROGRAM, EXTENT PERMITTED APPLICABLE LAW. EXCEPT OTHERWISE STATED WRITING COPYRIGHT HOLDERS /PARTIES PROVIDE PROGRAM “” WITHOUT WARRANTY KIND, EITHER EXPRESSED IMPLIED, INCLUDING, LIMITED , IMPLIED WARRANTIES MERCHANTABILITY FITNESS PARTICULAR PURPOSE. ENTIRE RISK QUALITY PERFORMANCE PROGRAM . PROGRAM PROVE DEFECTIVE, ASSUME COST NECESSARY SERVICING, REPAIR CORRECTION.","code":""},{"path":"https://danigiro.github.io/FoReco/LICENSE.html","id":"id_16-limitation-of-liability","dir":"","previous_headings":"TERMS AND CONDITIONS","what":"16. Limitation of Liability","title":"GNU General Public License","text":"EVENT UNLESS REQUIRED APPLICABLE LAW AGREED WRITING COPYRIGHT HOLDER, PARTY MODIFIES /CONVEYS PROGRAM PERMITTED , LIABLE DAMAGES, INCLUDING GENERAL, SPECIAL, INCIDENTAL CONSEQUENTIAL DAMAGES ARISING USE INABILITY USE PROGRAM (INCLUDING LIMITED LOSS DATA DATA RENDERED INACCURATE LOSSES SUSTAINED THIRD PARTIES FAILURE PROGRAM OPERATE PROGRAMS), EVEN HOLDER PARTY ADVISED POSSIBILITY DAMAGES.","code":""},{"path":"https://danigiro.github.io/FoReco/LICENSE.html","id":"id_17-interpretation-of-sections-15-and-16","dir":"","previous_headings":"TERMS AND CONDITIONS","what":"17. Interpretation of Sections 15 and 16","title":"GNU General Public License","text":"disclaimer warranty limitation liability provided given local legal effect according terms, reviewing courts shall apply local law closely approximates absolute waiver civil liability connection Program, unless warranty assumption liability accompanies copy Program return fee. END TERMS CONDITIONS","code":""},{"path":"https://danigiro.github.io/FoReco/LICENSE.html","id":"how-to-apply-these-terms-to-your-new-programs","dir":"","previous_headings":"","what":"How to Apply These Terms to Your New Programs","title":"GNU General Public License","text":"develop new program, want greatest possible use public, best way achieve make free software everyone can redistribute change terms. , attach following notices program. safest attach start source file effectively state exclusion warranty; file least “copyright” line pointer full notice found. Also add information contact electronic paper mail. program terminal interaction, make output short notice like starts interactive mode: hypothetical commands show w show c show appropriate parts General Public License. course, program’s commands might different; GUI interface, use “box”. also get employer (work programmer) school, , sign “copyright disclaimer” program, necessary. information , apply follow GNU GPL, see <http://www.gnu.org/licenses/>. GNU General Public License permit incorporating program proprietary programs. program subroutine library, may consider useful permit linking proprietary applications library. want , use GNU Lesser General Public License instead License. first, please read <http://www.gnu.org/philosophy/--lgpl.html>.","code":"<one line to give the program's name and a brief idea of what it does.> Copyright (C) 2020 Daniele Girolimetto; Tommaso Di Fonzo  This program is free software: you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version.  This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with this program.  If not, see <http://www.gnu.org/licenses/>. FoReco Copyright (C) 2020 Daniele Girolimetto; Tommaso Di Fonzo This program comes with ABSOLUTELY NO WARRANTY; for details type 'show w'. This is free software, and you are welcome to redistribute it under certain conditions; type 'show c' for details."},{"path":"https://danigiro.github.io/FoReco/articles/Cross-sectional-forecast-reconciliation.html","id":"introduction","dir":"Articles","previous_headings":"","what":"Introduction","title":"Cross-sectional forecast reconciliation","text":"vignette demonstrates use FoReco package cross-sectional forecast reconciliation. work examples using grouped general linearly constrained time series, showing obtain base forecasts, reconcile forecasts, address practical challenges non-negativity constraints immutable forecasts. also explore probabilistic forecast reconciliation.","code":""},{"path":"https://danigiro.github.io/FoReco/articles/Cross-sectional-forecast-reconciliation.html","id":"packages","dir":"Articles","previous_headings":"Introduction","what":"Packages","title":"Cross-sectional forecast reconciliation","text":"First, load necessary packages.","code":"library(FoReco)   # -> To perform reconciliation library(forecast)  # -> To obtain base forecasts"},{"path":"https://danigiro.github.io/FoReco/articles/Cross-sectional-forecast-reconciliation.html","id":"vndata-groupped-time-series","dir":"Articles","previous_headings":"","what":"vndata: Groupped time series","title":"Cross-sectional forecast reconciliation","text":"use vndata dataset (Wickramasuriya et al., 2018), contains grouped time series data, vnaggmat, corresponding aggregation matrix. See dataset vignette details.","code":"data(vndata)      # dataset data(vnaggmat)    # Agg mat matrix"},{"path":"https://danigiro.github.io/FoReco/articles/Cross-sectional-forecast-reconciliation.html","id":"base-forecast","dir":"Articles","previous_headings":"vndata: Groupped time series","what":"Base forecast","title":"Cross-sectional forecast reconciliation","text":"obtained base forecasts, fit ETS model log transformation series. handle zeros replacing half minimum non-zero value series (Wickramasuriya et al., 2020), fit ETS model generate forecasts. extract point forecasts residuals fitted models.","code":"model <- setNames(vector(mode='list', length=NCOL(vndata)), colnames(vndata)) fc_obj <- setNames(vector(mode='list', length=NCOL(vndata)), colnames(vndata))  # ETS model with log transformation ets_log <- function(x, ...){   x[x==0] <- min(x[x!=0])/2   ets(x, lambda = 0, ...) }  for(i in 1:NCOL(vndata)){   model[[i]] <- ets_log(vndata[, i])   fc_obj[[i]] <- forecast(model[[i]], h = 12) } # Point forecasts base <- do.call(cbind, lapply(fc_obj, function(x) x$mean)) str(base, give.attr = FALSE) #>  Time-Series [1:12, 1:525] from 2017 to 2018: 50651 21336 24567 29800 22846 ... # Residuals res <- do.call(cbind, lapply(fc_obj, residuals, type = \"response\")) str(res, give.attr = FALSE) #>  Time-Series [1:228, 1:525] from 1998 to 2017: 2143 -970 -115 133 951 ..."},{"path":"https://danigiro.github.io/FoReco/articles/Cross-sectional-forecast-reconciliation.html","id":"point-forecast-reconciliation","dir":"Articles","previous_headings":"vndata: Groupped time series","what":"Point forecast reconciliation","title":"Cross-sectional forecast reconciliation","text":"apply various reconciliation methods base forecasts ensure add correctly across different levels aggregation. Bottom-reconciliation (Dunn et al., 1976) aggregates forecasts lowest level higher levels. top-reconciliation genuine hierarchical/grouped time series (Gross & Sohl, 1990), forecast Total (top-level series, expected positive) disaggregated according proportional scheme (weights) : top-level value remains unchanged; bottom time series reconciled forecasts non-negative. level conditional coherent reconciliation (LCC) generalization original proposal Hollyman et al. (2021) reconciled forecasts conditional (.e., constrained ) base forecasts specific upper level hierarchy (Di Fonzo & Girolimetto, 2024). Finally can obtained optimal (least squares sense) combination cross-sectional reconciled forecast (Girolimetto & Di Fonzo, 2023; Panagiotelis et al., 2021; Wickramasuriya et al., 2018). following table shows options optimal combination cross-sectional reconciliation function csrec().","code":"fc_bts <- base[, colnames(vnaggmat)] rf_bu <- csbu(fc_bts, agg_mat = vnaggmat) str(rf_bu, give.attr = FALSE) #>  num [1:12, 1:525] 44094 18218 20585 25563 19385 ... bts <- vndata[, colnames(vnaggmat)] total <- vndata[, \"Total\"] fc_total <- base[, \"Total\"]  # Average historical proportions - Gross-Sohl method A p_gsa <- colMeans(apply(bts, 2, function(x) x/total)) rf_td_gsa <- cstd(fc_total, agg_mat = vnaggmat, weights = p_gsa) str(rf_td_gsa, give.attr = FALSE) #>  num [1:12, 1:525] 50651 21336 24567 29800 22846 ...  # Proportions of the historical averages - Gross-Sohl method F p_gsf <- colMeans(bts)/mean(total) rf_td_gsf <- cstd(fc_total, agg_mat = vnaggmat, weights = p_gsf) str(rf_td_gsf, give.attr = FALSE) #>  num [1:12, 1:525] 50651 21336 24567 29800 22846 ... rf_lcc <- cslcc(base = base, agg_mat = vnaggmat,                 res = res, comb = \"wls\") str(rf_lcc, give.attr = FALSE) #>  num [1:12, 1:525] 47896 20405 23276 28275 21938 ... rf_opt <- csrec(base = base, agg_mat = vnaggmat, res = res, comb = \"shr\") str(rf_opt, give.attr = FALSE) #>  num [1:12, 1:525] 49160 21622 24815 29433 23260 ..."},{"path":[]},{"path":"https://danigiro.github.io/FoReco/articles/Cross-sectional-forecast-reconciliation.html","id":"non-negativity-issues","dir":"Articles","previous_headings":"vndata: Groupped time series > Practical challenges","what":"Non negativity issues","title":"Cross-sectional forecast reconciliation","text":"Unfortunately, reconciled forecasts contain negative values, even though used non-negative base forecasts reconciliation. address issue, can use two approaches: State---art numerical optimization procedure, osqp (Stellato et al., 2020). Simple heuristic strategy: set-negative--zero, sntz (Di Fonzo & Girolimetto, 2023).","code":"recoinfo(rf_opt) #> ✔ Optimal Cross-sectional Forecast Reconciliation #> ℹ FoReco function: `csrec` #> ℹ Covariance approximation: `shr` #> ℹ Non-negative forecasts: `FALSE` rf_osqp <- csrec(base = base, agg_mat = vnaggmat, res = res, comb = \"shr\", nn = \"osqp\") tmp <- recoinfo(rf_osqp) #> ✔ Optimal Cross-sectional Forecast Reconciliation #> ℹ FoReco function: `csrec` #> ℹ Covariance approximation: `shr` #> ℹ Non-negative forecasts: `TRUE` tmp$info # OSQP information matrix  #>     obj_val  run_time iter      pri_res status status_polish #> 1 -3197.129 0.1950355  450 7.983912e-12      1             1 rf_sntz <- csrec(base = base, agg_mat = vnaggmat, res = res, comb = \"shr\",                       nn = \"sntz\") recoinfo(rf_sntz) #> ✔ Optimal Cross-sectional Forecast Reconciliation #> ℹ FoReco function: `csrec` #> ℹ Covariance approximation: `shr` #> ℹ Non-negative forecasts: `TRUE`"},{"path":"https://danigiro.github.io/FoReco/articles/Cross-sectional-forecast-reconciliation.html","id":"a-priori-constrained-immutable-forecasts","dir":"Articles","previous_headings":"vndata: Groupped time series > Practical challenges","what":"A priori constrained (immutable) forecasts","title":"Cross-sectional forecast reconciliation","text":"Sometimes may wish incorporate priori knowledge reconciliation process (Zhang et al., 2023) order improve accuracy reconciled forecasts. example, suppose want fix forecasts states level series base forecasts values.","code":"rf_imm <- csrec(base = base, agg_mat = vnaggmat, res = res, comb = \"shr\", immutable = c(2:8)) str(rf_imm, give.attr = FALSE) #>  num [1:12, 1:525] 50403 21300 24398 29664 22962 ... round(rf_imm[, 2:8] - base[, 2:8], 6) #>          A B C D E F G #> Jan 2017 0 0 0 0 0 0 0 #> Feb 2017 0 0 0 0 0 0 0 #> Mar 2017 0 0 0 0 0 0 0 #> Apr 2017 0 0 0 0 0 0 0 #> May 2017 0 0 0 0 0 0 0 #> Jun 2017 0 0 0 0 0 0 0 #> Jul 2017 0 0 0 0 0 0 0 #> Aug 2017 0 0 0 0 0 0 0 #> Sep 2017 0 0 0 0 0 0 0 #> Oct 2017 0 0 0 0 0 0 0 #> Nov 2017 0 0 0 0 0 0 0 #> Dec 2017 0 0 0 0 0 0 0"},{"path":"https://danigiro.github.io/FoReco/articles/Cross-sectional-forecast-reconciliation.html","id":"probabilistic-forecast-reconciliation","dir":"Articles","previous_headings":"vndata: Groupped time series","what":"Probabilistic forecast reconciliation","title":"Cross-sectional forecast reconciliation","text":"Panagiotelis et al. (2023) shows sample reconciled distribution can obtained reconciling sample incoherent distribution. distinction incoherent sample reconciliation allows us separate two steps. can use non-parametric method, joint block bootstrap simulate \\(B\\) samples reconciled . parametric method assumes normal distribution (Gaussian), generate incoherent sample set forecasts.","code":"# Base forecasts' sample: # we simulate from the base models by sampling errors  # while keeping the cross-sectional dimension fixed. B <- 100 base_csjb <- csboot(model, B, 12)$sample  # Reconciled forecasts' sample:  # we reconcile each member of a sample from the incoherent distribution. reco_csjb <- apply(base_csjb, 3, csrec, agg_mat = vnaggmat, res = res, nn = \"sntz\",                    comb = \"shr\", keep = \"recf\", simplify = FALSE) reco_csjb <- simplify2array(reco_csjb) rownames(reco_csjb) <- rownames(base_csjb) str(reco_csjb, give.attr = FALSE) #>  num [1:100, 1:525, 1:12] 47753 48449 52862 53098 54893 ... # Multi-step residuals hres <- lapply(1:12, function(h)    sapply(model, residuals, type='response', h = h)) # List of H=12 covariance matrix (one for each forecast horizon) cov_shr <- lapply(hres, function(r) cscov(comb = \"shr\", res = r))   # Base forecasts' sample: # we simulate from a multivariate normal distribution. base_csg <- lapply(1:12, function(h) MASS::mvrnorm(n = B, mu = base[h, ], Sigma = cov_shr[[h]])) base_csg <- simplify2array(base_csg) dimnames(base_csg) <- dimnames(base_csjb)  # Reconciled forecasts' sample: # we reconcile each member of the base forecasts' sample. reco_csg <- apply(base_csg, 3, csrec, agg_mat = vnaggmat, res = res, nn = \"sntz\",                    comb = \"shr\", keep = \"recf\", simplify = FALSE) reco_csg <- simplify2array(reco_csg) rownames(reco_csg) <- rownames(base_csg) str(reco_csg, give.attr = FALSE) #>  num [1:100, 1:525, 1:12] 48405 49013 50513 51014 48092 ..."},{"path":"https://danigiro.github.io/FoReco/articles/Cross-sectional-forecast-reconciliation.html","id":"itagdp-general-linearly-constrained-multiple-time-series","dir":"Articles","previous_headings":"","what":"itagdp: general linearly constrained multiple time series","title":"Cross-sectional forecast reconciliation","text":"section, work itagdp dataset corresponding zero-constrained matrix gdpconsmat. dataset illustrates reconciliation complex linear constraints unique aggregation available. See dataset vignette details.","code":"data(itagdp)      # dataset data(gdpconsmat)  # Zero-constrained matrix"},{"path":"https://danigiro.github.io/FoReco/articles/Cross-sectional-forecast-reconciliation.html","id":"base-forecasts","dir":"Articles","previous_headings":"itagdp: general linearly constrained multiple time series","what":"Base forecasts","title":"Cross-sectional forecast reconciliation","text":"fit ARIMA models series generate base forecasts.","code":"model <- setNames(vector(mode='list', length=NCOL(itagdp)), colnames(itagdp)) fc_obj <- setNames(vector(mode='list', length=NCOL(itagdp)), colnames(itagdp)) for(i in 1:NCOL(itagdp)){   model[[i]] <- auto.arima(itagdp[, i])   fc_obj[[i]] <- forecast(model[[i]], h = 4) } # Point forecasts base <- do.call(cbind, lapply(fc_obj, function(x) x$mean)) str(base, give.attr = FALSE) #>  Time-Series [1:4, 1:21] from 2020 to 2021: 435117 454372 451935 483302 169348 ... # Residuals res <- do.call(cbind, lapply(fc_obj, function(x) x$residuals)) str(res, give.attr = FALSE) #>  Time-Series [1:80, 1:21] from 2000 to 2020: 167.9 89.7 51.4 -43.6 -630.9 ..."},{"path":"https://danigiro.github.io/FoReco/articles/Cross-sectional-forecast-reconciliation.html","id":"point-forecast-reconciliation-1","dir":"Articles","previous_headings":"itagdp: general linearly constrained multiple time series","what":"Point forecast reconciliation","title":"Cross-sectional forecast reconciliation","text":"apply optimal reconciliation method base forecasts, considering linear constraints defined gdpconsmat.","code":"rf_opt <- csrec(base = base, cons_mat = gdpconsmat, res = res, comb = \"wls\") str(rf_opt, give.attr = FALSE) #>  num [1:4, 1:21] 434329 453375 451278 482269 169366 ..."},{"path":"https://danigiro.github.io/FoReco/articles/Cross-sectional-forecast-reconciliation.html","id":"practical-challenge-immutable-forecast","dir":"Articles","previous_headings":"itagdp: general linearly constrained multiple time series > Point forecast reconciliation","what":"Practical challenge: immutable forecast","title":"Cross-sectional forecast reconciliation","text":"case, want fix forecasts top level series (\\(GDP\\)) base forecasts values.","code":"rf_imm <- csrec(base = base, cons_mat = gdpconsmat, res = res, comb = \"wls\", immutable = c(1)) str(rf_imm, give.attr = FALSE) #>  num [1:4, 1:21] 435117 454372 451935 483302 169424 ... rf_imm[,1]-base[,1] #>      Qtr1 Qtr2 Qtr3 Qtr4 #> 2020    0    0    0    0"},{"path":"https://danigiro.github.io/FoReco/articles/Cross-sectional-forecast-reconciliation.html","id":"probabilistic-forecast-reconciliation-1","dir":"Articles","previous_headings":"itagdp: general linearly constrained multiple time series","what":"Probabilistic forecast reconciliation","title":"Cross-sectional forecast reconciliation","text":"can use non-parametric method, joint block bootstrap simulate \\(B\\) samples reconciled . Alternatively, can use parametric method.","code":"# Base forecasts' sample: # we simulate from the base models by sampling errors  # while keeping the cross-sectional dimension fixed. B <- 100 base_csjb <- csboot(model, B, 4)$sample  # Reconciled forecasts' sample:  # we reconcile each member of a sample from the incoherent distribution. reco_csjb <- apply(base_csjb, 3, csrec, cons_mat = gdpconsmat, res = res,                     comb = \"shr\", keep = \"recf\", simplify = FALSE) reco_csjb <- simplify2array(reco_csjb) rownames(reco_csjb) <- rownames(base_csjb) str(reco_csjb, give.attr = FALSE) #>  num [1:100, 1:21, 1:4] 435077 433615 439269 439202 429506 ... # Multi-step residuals hres <- lapply(1:4, function(h)    sapply(model, residuals, type='response', h = h)) # List of H=12 covariance matrix (one for each forecast horizon) cov_shr <- lapply(hres, function(r) cscov(comb = \"shr\", res = r))   # Base forecasts' sample: # we simulate from a multivariate normal distribution. base_csg <- lapply(1:4, function(h) MASS::mvrnorm(n = B, mu = base[h, ], Sigma = cov_shr[[h]])) base_csg <- simplify2array(base_csg) dimnames(base_csg) <- dimnames(base_csjb)  # Reconciled forecasts' sample: # we reconcile each member of the base forecasts' sample. reco_csg <- apply(base_csg, 3, csrec, cons_mat = gdpconsmat, res = res,                     comb = \"shr\", keep = \"recf\", simplify = FALSE) reco_csg <- simplify2array(reco_csg) rownames(reco_csg) <- rownames(base_csg) str(reco_csg, give.attr = FALSE) #>  num [1:100, 1:21, 1:4] 435745 438742 434423 432915 428202 ..."},{"path":[]},{"path":"https://danigiro.github.io/FoReco/articles/Cross-temporal-forecast-reconciliation.html","id":"introduction","dir":"Articles","previous_headings":"","what":"Introduction","title":"Cross-temporal forecast reconciliation","text":"vignette demonstrates process cross-temporal forecast reconciliation using FoReco package. vignette covers following steps: Preparing loading necessary packages data. Generating base forecasts grouped time series. Reconciling point forecasts. Addressing practical challenges non-negativity issues. Exploring probabilistic forecast reconciliation.","code":""},{"path":"https://danigiro.github.io/FoReco/articles/Cross-temporal-forecast-reconciliation.html","id":"packages","dir":"Articles","previous_headings":"Introduction","what":"Packages","title":"Cross-temporal forecast reconciliation","text":"First, load necessary packages.","code":"library(FoReco)   # -> To perform reconciliation library(forecast)  # -> To obtain base forecasts library(GMCM)      # -> Sample from a multivariate normal distibution"},{"path":"https://danigiro.github.io/FoReco/articles/Cross-temporal-forecast-reconciliation.html","id":"vndata-groupped-monthly-time-series","dir":"Articles","previous_headings":"","what":"vndata: Groupped monthly time series","title":"Cross-temporal forecast reconciliation","text":"use vndata dataset (Wickramasuriya et al., 2018), contains grouped monthly time series data, vnaggmat, corresponding aggregation matrix. See dataset vignette details.","code":"data(vndata)      # dataset data(vnaggmat)    # Agg mat matrix"},{"path":"https://danigiro.github.io/FoReco/articles/Cross-temporal-forecast-reconciliation.html","id":"base-forecast","dir":"Articles","previous_headings":"vndata: Groupped monthly time series","what":"Base forecast","title":"Cross-temporal forecast reconciliation","text":"obtained base forecasts, fit ETS model log transformation series. handle zeros replacing half minimum non-zero value series (Wickramasuriya et al., 2020), fit ETS model generate forecasts. obtain twelve-, six-, four-, three-, two-, one-step-ahead base forecasts monthly data aggregation 2, 3, 4, 6, 12 months. extract point forecasts residuals fitted models.","code":"te_set <- tetools(12)$set m <- max(te_set) data_k <- aggts(vndata, te_set) model <- setNames(rep(list(setNames(vector(mode='list', length=NCOL(vndata)), colnames(vndata))),                        length(te_set)), paste0(\"k-\", te_set)) fc_obj <- setNames(rep(list(setNames(vector(mode='list', length=NCOL(vndata)), colnames(vndata))),                        length(te_set)), paste0(\"k-\", te_set))  # ETS model with log transformation ets_log <- function(x, ...){   x[x==0] <- min(x[x!=0])/2   ets(x, lambda = 0, ...) }  for(k in te_set){   idk <- paste0(\"k-\", k)   for(i in 1:NCOL(vndata)){     ids <- colnames(vndata)[i]     model[[idk]][[ids]] <- ets_log(data_k[[idk]][,i])     fc_obj[[idk]][[ids]] <- forecast(model[[idk]][[ids]], h = m/k)   }   cat(k, \" \") } #> 12  6  4  3  2  1 # Point forecasts base <- lapply(fc_obj, function(x) rbind(sapply(x, function(y) y$mean))) str(base, give.attr=FALSE) #> List of 6 #>  $ k-12: num [1, 1:525] 327178 99476 63854 79348 20809 ... #>  $ k-6 : num [1:2, 1:525] 171018 157987 52963 46291 35704 ... #>  $ k-4 : num [1:3, 1:525] 126347 98437 105568 41869 29839 ... #>  $ k-3 : num [1:4, 1:525] 96845 75196 79409 79498 30443 ... #>  $ k-2 : num [1:6, 1:525] 72593 54242 45402 53122 55872 ... #>  $ k-1 : num [1:12, 1:525] 50651 21336 24567 29800 22846 ...  # Residuals res <- lapply(fc_obj, function(x) rbind(sapply(x, residuals, type = \"response\"))) str(res, give.attr=FALSE) #> List of 6 #>  $ k-12: num [1:19, 1:525] 3241 3444 -1935 -4632 8946 ... #>  $ k-6 : num [1:38, 1:525] -140.6 -408 4588.6 -4072.2 -71.5 ... #>  $ k-4 : num [1:57, 1:525] -20.7 19.8 -1219.6 4592.3 -706.1 ... #>  $ k-3 : num [1:76, 1:525] 192 -542 674 -1212 3679 ... #>  $ k-2 : num [1:114, 1:525] -329 -720 -453 538 -693 ... #>  $ k-1 : num [1:228, 1:525] 2143 -970 -115 133 951 ..."},{"path":"https://danigiro.github.io/FoReco/articles/Cross-temporal-forecast-reconciliation.html","id":"point-forecast-reconciliation","dir":"Articles","previous_headings":"vndata: Groupped monthly time series","what":"Point forecast reconciliation","title":"Cross-temporal forecast reconciliation","text":"Within FoReco, range reconciliation strategies available, including bottom-, top-, level conditional coherent forecast reconciliation, cross-temporal heuristics. Bottom-reconciliation (Dunn et al., 1976) aggregates high-frequency forecasts lowest cross-sectional level higher cross-temporal levels (Girolimetto et al., 2024). obtain list forecasts different orders aggregation, can use FoReco2matrix function. top-reconciliation hierarchical time series, forecast top-level series (Total) distributed proportionally ensure top-level value stays bottom-level forecasts non-negative (Gross & Sohl, 1990). perform cross-temporal reconciliation FoReco using complete set base forecasts (cross-sectional temporal level), necessary arrange base forecasts (residuals) matrix form. rows matrix represent cross-sectional variables, columns temporal dimension. level conditional coherent reconciliation (LCC) generalization original proposal Hollyman et al. (2021) Di Fonzo & Girolimetto (2024) include cross-temporal framework iterative procedure described Di Fonzo & Girolimetto (2023a) produces cross-temporally reconciled forecasts alternating forecast reconciliation along one single dimension (either cross-sectional temporal) iteration step. cross-temporal method Kourentzes & Athanasopoulos (2019), involves three steps: first, reconciling forecasts time series different temporal aggregation levels using temporal hierarchies; second, performing cross-sectional reconciliation temporal aggregation order; third, averaging projection matrices second step using cross-sectionally reconcile forecasts first step. contrast, can reverses steps starting cross-sectional reconciliation followed temporal reconciliation (Di Fonzo & Girolimetto, 2023a). Finally can obtained optimal (least squares sense) combination cross-temporal reconciled forecast (Di Fonzo & Girolimetto, 2023a; Girolimetto et al., 2024). following table shows options optimal combination cross-temporal reconciliation function ctrec().","code":"fc_bts <- t(base$`k-1`[, colnames(vnaggmat)]) rf_bu <- ctbu(fc_bts, agg_order = m, agg_mat = vnaggmat) str(rf_bu, give.attr=FALSE) #>  num [1:525, 1:28] 280206 89744 55472 69366 16847 ... str(FoReco2matrix(rf_bu), give.attr=FALSE) #> List of 6 #>  $ k-12: num [1, 1:525] 280206 89744 55472 69366 16847 ... #>  $ k-6 : num [1:2, 1:525] 147023 133182 48055 41689 31372 ... #>  $ k-4 : num [1:3, 1:525] 108461 82962 88782 36173 25354 ... #>  $ k-3 : num [1:4, 1:525] 82898 64126 66292 66891 27564 ... #>  $ k-2 : num [1:6, 1:525] 62313 46149 38562 44400 46889 ... #>  $ k-1 : num [1:12, 1:525] 44094 18218 20585 25563 19385 ... bts_mat <- data_k$`k-1`[, colnames(vnaggmat)] tot_12 <- data_k$`k-12`[,1] fc_tot_12 <- base$`k-12`[,1]  # Average historical proportions - Gross-Sohl method A p_gsa <- apply(bts_mat, 2, function(y){   colMeans(apply(matrix(y, ncol = m, byrow = TRUE), 2, function(x) x/tot_12)) }) rf_td_gsa <- cttd(fc_tot_12, agg_order = m, weights = t(p_gsa), agg_mat = vnaggmat) str(rf_td_gsa, give.attr=FALSE) #>  num [1:525, 1:28] 327178 105757 63173 85397 22176 ...  # Proportions of the historical averages - Gross-Sohl method F p_gsf <- apply(bts_mat, 2, function(y){   colMeans(matrix(y, ncol = m, byrow = TRUE))/mean(tot_12) }) rf_td_gsf <- cttd(fc_tot_12, agg_order = m, weights = t(p_gsf), agg_mat = vnaggmat) str(rf_td_gsf, give.attr=FALSE) #>  num [1:525, 1:28] 327178 105656 63188 85290 22160 ... base_mat <- t(Reduce(rbind, base)) res_mat <- t(Reduce(rbind, res)) rf_lcc <- ctlcc(base = base_mat, agg_order = m, agg_mat = vnaggmat,                 res = res_mat, comb = \"wlsv\") str(rf_lcc, give.attr=FALSE) #>  num [1:525, 1:28] 316724 98441 62491 79420 19591 ... rf_ite <- iterec(base = base_mat, res = res_mat,                  cslist = list(agg_mat = vnaggmat, comb = \"shr\"),                   telist = list(agg_order = m, comb = \"wlsv\")) #> ── Iterative heuristic cross-temporal forecast reconciliation ────────────────── #> Legend: i = iteration; s = step. Norm = \"inf\". #>   i.s |        Temporal | Cross-sectional | #>     0 |         4869.77 |        23213.13 | #>   1.1 |            0.00 |        34262.16 | #>   1.2 |         6994.71 |            0.00 | #>   2.1 |            0.00 |         1112.59 | #>   2.2 |          342.66 |            0.00 | #>   3.1 |            0.00 |           47.08 | #>   3.2 |           16.48 |            0.00 | #>   4.1 |            0.00 |            2.15 | #>   4.2 |        7.91e-01 |            0.00 | #>   5.1 |            0.00 |        1.01e-01 | #>   5.2 |        3.79e-02 |            0.00 | #>   6.1 |            0.00 |        4.81e-03 | #>   6.2 |        1.81e-03 |            0.00 | #>   7.1 |            0.00 |        2.29e-04 | #>   7.2 |        8.68e-05 |            0.00 | #>   8.1 |            0.00 |        1.10e-05 | #>   8.2 |        4.15e-06 |            0.00 | #> ✔ Convergence achieved at iteration 8. #> ──────────────────────────────────────────────────────────────────────────────── str(rf_ite, give.attr=FALSE) #>  num [1:525, 1:28] 324066 98946 64400 80221 20703 ... rf_tcs <- tcsrec(base = base_mat, res = res_mat,                  cslist = list(agg_mat = vnaggmat, comb = \"shr\"),                   telist = list(agg_order = m, comb = \"wlsv\")) str(rf_tcs, give.attr=FALSE) #>  num [1:525, 1:28] 323553 98861 64315 80090 20660 ... rf_cst <- cstrec(base = base_mat, res = res_mat,                  cslist = list(agg_mat = vnaggmat, comb = \"shr\"),                   telist = list(agg_order = m, comb = \"wlsv\")) str(rf_cst, give.attr=FALSE) #>  num [1:525, 1:28] 324708 99123 64462 80416 20802 ... rf_opt <- ctrec(base = base_mat, agg_order = m, agg_mat = vnaggmat,                 res = res_mat, comb = \"wlsv\", approach = \"strc\") str(rf_opt, give.attr=FALSE) #>  num [1:525, 1:28] 314297 97383 62631 77793 19695 ..."},{"path":[]},{"path":"https://danigiro.github.io/FoReco/articles/Cross-temporal-forecast-reconciliation.html","id":"non-negativity-issues","dir":"Articles","previous_headings":"vndata: Groupped monthly time series > Practical challenges","what":"Non negativity issues","title":"Cross-temporal forecast reconciliation","text":"always true reconciled forecasts remain non-negative even base forecasts non-negative. example, consider case identity covariance matrix (\"ols\"). address issue, can use two approaches: State---art numerical optimization procedure, osqp (Stellato et al., 2020). Simple heuristic strategy: set-negative--zero, sntz (Di Fonzo & Girolimetto, 2023b).","code":"rf_ols <- ctrec(base = base_mat, agg_order = m, agg_mat = vnaggmat,                 res = res_mat, comb = \"ols\", approach = \"strc\") recoinfo(rf_ols) #> ✔ Optimal Cross-temporal Forecast Reconciliation #> ℹ FoReco function: `ctrec` #> ℹ Covariance approximation: `ols` #> ℹ Non-negative forecasts: `FALSE` rf_osqp <- ctrec(base = base_mat, agg_order = m, agg_mat = vnaggmat,                   approach = \"strc\", res = res_mat, comb = \"ols\", nn = \"osqp\") tmp <- recoinfo(rf_osqp) #> ✔ Optimal Cross-temporal Forecast Reconciliation #> ℹ FoReco function: `ctrec` #> ℹ Covariance approximation: `ols` #> ℹ Non-negative forecasts: `TRUE` tmp$info # OSQP information matrix  #>         obj_val run_time iter     pri_res status status_polish #> 1 -220421537281 26.69933  700 8.23701e-22      1             1 rf_sntz <- ctrec(base = base_mat, agg_order = m, agg_mat = vnaggmat,                  approach = \"strc\", res = res_mat, comb = \"ols\", nn = \"sntz\") recoinfo(rf_sntz) #> ✔ Optimal Cross-temporal Forecast Reconciliation #> ℹ FoReco function: `ctrec` #> ℹ Covariance approximation: `ols` #> ℹ Non-negative forecasts: `TRUE`"},{"path":"https://danigiro.github.io/FoReco/articles/Cross-temporal-forecast-reconciliation.html","id":"a-priori-constrained-immutable-forecasts","dir":"Articles","previous_headings":"vndata: Groupped monthly time series > Practical challenges","what":"A priori constrained (immutable) forecasts","title":"Cross-temporal forecast reconciliation","text":"Sometimes may wish incorporate priori knowledge reconciliation process (Zhang et al., 2023) order improve accuracy reconciled forecasts. example, suppose want fix forecasts states level annual series base forecasts values.","code":"rf_imm <- ctrec(base = base_mat, agg_order = m, agg_mat = vnaggmat, approach = \"strc\",                 res = res_mat, comb = \"wlsv\", immutable = cbind(2:8, 12, 1)) str(rf_imm, give.attr=FALSE) #>  num [1:525, 1:28] 321957 99476 63854 79348 20809 ... round(rf_imm[2:8,1] - base_mat[2:8,1], 6) #> A B C D E F G  #> 0 0 0 0 0 0 0"},{"path":"https://danigiro.github.io/FoReco/articles/Cross-temporal-forecast-reconciliation.html","id":"exploring-a-subset-of-temporal-aggregation-orders","dir":"Articles","previous_headings":"vndata: Groupped monthly time series > Practical challenges","what":"Exploring a subset of temporal aggregation orders","title":"Cross-temporal forecast reconciliation","text":"approaches far involved considering factors \\(m\\) potential aggregation orders. Nevertheless, worth noting also focus given subset factors. example, interested monthly, quarterly annual forecasts.","code":"te_subset <- c(12, 3, 1) base_mat2 <- t(Reduce(rbind, base[paste0(\"k-\", te_subset)])) res_mat2 <- t(Reduce(rbind, res[paste0(\"k-\", te_subset)])) rf_sub <- ctrec(base = base_mat2, agg_order = te_subset, agg_mat = vnaggmat,                 res = res_mat2, comb = \"wlsv\", approach = \"strc\") str(rf_sub, give.attr=FALSE) #>  num [1:525, 1:17] 313400 97327 62517 77555 19511 ..."},{"path":"https://danigiro.github.io/FoReco/articles/Cross-temporal-forecast-reconciliation.html","id":"probabilistic-forecast-reconciliation","dir":"Articles","previous_headings":"vndata: Groupped monthly time series","what":"Probabilistic forecast reconciliation","title":"Cross-temporal forecast reconciliation","text":"Girolimetto et al. (2024) extends cross-temporal framework probabilistic results presented Panagiotelis et al. (2023) cross-sectional reconciliation. reconciliation probabilistic forecasts two-step process: first, sample incoherent distribution, reconcile sample. can use non-parametric method, joint block bootstrap simulate \\(B\\) samples reconciled . parametric method assumes normal distribution (Gaussian), generate incoherent sample set forecasts. Since simulate multivariate normal distribution size 14700, use diagonal covariance matrix vignette. However, ’s important note choice result significantly narrow variance reconciled forecasts.","code":"# Base forecasts' sample B <- 100 # Base forecasts' sample base_ctjb <- ctboot(model, B, agg_order = m)$sample  str(base_ctjb[1:3], give.attr=FALSE) #> List of 3 #>  $ : num [1:28, 1:525] 340334 176732 167759 127537 104309 ... #>  $ : num [1:28, 1:525] 331164 176362 156864 131731 99921 ... #>  $ : num [1:28, 1:525] 324965 170935 159797 128095 94189 ...  # # Reconciled forecasts' sample: # reco_ctjb <- lapply(base_ctjb, function(boot_base){ #   octrec(t(boot_base), m = 12, C = C, res = res_ct,  #          comb = \"bdshr\", keep = \"recf\", nn = TRUE, nn_type = \"sntz\") # })  # Tip to speed up the time: B reconciliation to 1 reconciliation ctjb_mlist <- lapply(base_ctjb, function(x) FoReco2matrix(t(x), agg_order = m)) ctjb_list <- unlist(ctjb_mlist, recursive=FALSE) id <- sort.int(factor(names(ctjb_list), paste0(\"k-\", te_set), ordered = TRUE),                 index.return =TRUE)$ix base_ctjb_mat <- t(Reduce(\"rbind\", ctjb_list[id])) str(base_ctjb_mat, give.attr=FALSE) #>  num [1:525, 1:2800] 340334 103766 64980 80788 22279 ...  # Reconciled forecasts' sample: reco_ctjb <- ctrec(base = base_ctjb_mat, agg_order = m, agg_mat = vnaggmat,                    res = res_mat, comb = \"wlsv\", approach = \"strc\", nn = \"sntz\") str(reco_ctjb, give.attr=FALSE) #>  num [1:525, 1:2800] 342661 102372 67805 80571 21623 ... # Multi-step residuals hres <- lapply(model, function(fit)   lapply(1:frequency(fit[[1]]$x), function(h)      sapply(fit, residuals, type='response', h = h))) hres_ct <- t(Reduce(\"rbind\", lapply(hres, arrange_hres))) # Re-arrenge multi-step residuals in a matrix form mres <- res2matrix(hres_ct, agg_order = m)  # cov_shr <- shrink_estim(na.omit(mres)) # Time and computational intensive to use, but the better one cov_wls <- diag(x = diag(cov(na.omit(mres))))   # Base forecasts' sample: base_ctg <- GMCM::rmvnormal(B, mu = res2matrix(base_mat, agg_order = m),                              sigma = cov_wls) base_ctg <- apply(base_ctg, 1, function(x) matrix(x, ncol = NCOL(itagdp)), simplify = FALSE)  # Tip to speed up the time: B reconciliation to 1 reconciliation ctg_mlist <- lapply(base_ctjb, function(x) FoReco2matrix(t(x), agg_order = m)) ctg_list <- unlist(ctg_mlist, recursive=FALSE) id <- sort.int(factor(names(ctg_list), paste0(\"k-\", te_set), ordered = TRUE),                 index.return =TRUE)$ix base_ctg_mat <- t(Reduce(\"rbind\", ctg_list[id])) str(base_ctg_mat, give.attr=FALSE) #>  num [1:525, 1:2800] 340334 103766 64980 80788 22279 ...  # Reconciled forecasts' sample: reco_ctg <- ctrec(base = base_ctg_mat, agg_order = m, agg_mat = vnaggmat,                   res = res_mat, comb = \"wlsv\", approach = \"strc\", nn = \"sntz\") str(reco_ctg, give.attr=FALSE) #>  num [1:525, 1:2800] 342661 102372 67805 80571 21623 ..."},{"path":"https://danigiro.github.io/FoReco/articles/Cross-temporal-forecast-reconciliation.html","id":"itagdp-general-linearly-constrained-multiple-quarterly-time-series","dir":"Articles","previous_headings":"","what":"itagdp: general linearly constrained multiple quarterly time series","title":"Cross-temporal forecast reconciliation","text":"section, work itagdp dataset corresponding zero-constrained matrix gdpconsmat. dataset illustrates reconciliation complex linear constraints unique aggregation available. See dataset vignette details.","code":"data(itagdp)      # dataset data(gdpconsmat)    # Agg mat matrix"},{"path":"https://danigiro.github.io/FoReco/articles/Cross-temporal-forecast-reconciliation.html","id":"base-forecast-1","dir":"Articles","previous_headings":"itagdp: general linearly constrained multiple quarterly time series","what":"Base forecast","title":"Cross-temporal forecast reconciliation","text":"fit ARIMA models series generate base forecasts. data quarterly multivariate time series obtain four-, two-, one-step-ahead base forecasts quarterly data aggregation 2, 4 quarters.","code":"te_set <- tetools(4)$set m <- max(te_set) data_k <- aggts(itagdp, te_set) model <- setNames(rep(list(setNames(vector(mode='list', length=NCOL(itagdp)), colnames(itagdp))),                        length(te_set)), paste0(\"k-\", te_set)) fc_obj <- setNames(rep(list(setNames(vector(mode='list', length=NCOL(itagdp)), colnames(itagdp))),                        length(te_set)), paste0(\"k-\", te_set))  for(k in te_set){   idk <- paste0(\"k-\", k)   for(i in 1:NCOL(itagdp)){     ids <- colnames(itagdp)[i]     model[[idk]][[ids]] <- ets(data_k[[idk]][,i])     fc_obj[[idk]][[ids]] <- forecast(model[[idk]][[ids]], h = m/k)   }   cat(k, \" \") } #> 4  2  1 # Point forecasts base <- lapply(fc_obj, function(x) rbind(sapply(x, function(y) y$mean))) str(base, give.attr = FALSE) #> List of 3 #>  $ k-4: num [1, 1:21] 1811793 736509 1748222 1421782 326061 ... #>  $ k-2: num [1:2, 1:21] 884015 928287 351866 379716 855453 ... #>  $ k-1: num [1:4, 1:21] 431993 451829 449546 480841 167984 ...  # Residuals res <- lapply(fc_obj, function(x) rbind(sapply(x, residuals, type = \"response\"))) str(res, give.attr = FALSE) #> List of 3 #>  $ k-4: num [1:20, 1:21] -45068 22792 8057 8051 22851 ... #>  $ k-2: num [1:40, 1:21] -14138 421 9758 -4257 2225 ... #>  $ k-1: num [1:80, 1:21] -2778 -1745 -448 4068 3088 ..."},{"path":"https://danigiro.github.io/FoReco/articles/Cross-temporal-forecast-reconciliation.html","id":"point-forecast-reconciliation-1","dir":"Articles","previous_headings":"itagdp: general linearly constrained multiple quarterly time series","what":"Point forecast reconciliation","title":"Cross-temporal forecast reconciliation","text":"apply optimal reconciliation method base forecasts, considering linear constraints defined gdpconsmat.","code":"base_mat <- t(Reduce(rbind, base)) res_mat <- t(Reduce(rbind, res)) rf_opt <- ctrec(base = base_mat, agg_order = m, cons_mat = gdpconsmat,                 res = res_mat, comb = \"bdshr\") str(rf_opt, give.attr = FALSE) #>  num [1:21, 1:7] 1807755 730746 1739243 1417381 321862 ..."},{"path":"https://danigiro.github.io/FoReco/articles/Cross-temporal-forecast-reconciliation.html","id":"practical-challenge-immutable-forecast","dir":"Articles","previous_headings":"itagdp: general linearly constrained multiple quarterly time series > Point forecast reconciliation","what":"Practical challenge: immutable forecast","title":"Cross-temporal forecast reconciliation","text":"case, want fix forecasts top level series (\\(GDP\\)) annual temporally aggreated series (\\(k = 4\\)) base forecasts values.","code":"rf_imm <- ctrec(base = base_mat, agg_order = m, cons_mat = gdpconsmat,                 res = res_mat, comb = \"wlsv\", immutable = rbind(c(1,4,1))) str(rf_imm, give.attr = FALSE) #>  num [1:21, 1:7] 1811793 731220 1743712 1418685 325027 ... rf_imm[1,1] - base_mat[1,1] #> GDP  #>   0"},{"path":"https://danigiro.github.io/FoReco/articles/Cross-temporal-forecast-reconciliation.html","id":"probabilistic-forecast-reconciliation-1","dir":"Articles","previous_headings":"itagdp: general linearly constrained multiple quarterly time series","what":"Probabilistic forecast reconciliation","title":"Cross-temporal forecast reconciliation","text":"can use non-parametric method, joint block bootstrap simulate \\(B\\) samples reconciled . Alternatively, can use parametric method.","code":"B <- 100 # Base forecasts' sample base_ctjb <- ctboot(model, B, agg_order = m)$sample  str(base_ctjb[1:3], give.attr = FALSE) #> List of 3 #>  $ : num [1:7, 1:21] 1715859 849266 892664 419181 436858 ... #>  $ : num [1:7, 1:21] 1840756 891454 938282 432570 458454 ... #>  $ : num [1:7, 1:21] 1840756 891454 938282 432570 458454 ...  # # Reconciled forecasts' sample: # reco_ctjb <- lapply(base_ctjb, function(boot_base){ #   octrec(t(boot_base), m = 12, C = C, res = res_ct,  #          comb = \"bdshr\", keep = \"recf\", nn = TRUE, nn_type = \"sntz\") # })  # Tip to speed up the time: B reconciliation to 1 reconciliation ctjb_mlist <- lapply(base_ctjb, function(x) FoReco2matrix(t(x), agg_order = m)) ctjb_list <- unlist(ctjb_mlist, recursive=FALSE) id <- sort.int(factor(names(ctjb_list), paste0(\"k-\", te_set), ordered = TRUE),                 index.return =TRUE)$ix base_ctjb_mat <- t(Reduce(\"rbind\", ctjb_list[id])) str(base_ctjb_mat, give.attr = FALSE) #>  num [1:21, 1:700] 1715859 708966 1655955 1382431 281299 ...  # Reconciled forecasts' sample: reco_ctjb <- ctrec(base = base_ctjb_mat, agg_order = m, cons_mat = gdpconsmat,                    res = res_mat, comb = \"wlsv\") str(reco_ctjb, give.attr = FALSE) #>  num [1:21, 1:700] 1755274 713842 1682939 1387490 295448 ... # Multi-step residuals hres <- lapply(model, function(fit)   lapply(1:frequency(fit[[1]]$x), function(h)      sapply(fit, residuals, type='response', h = h))) hres_ct <- t(Reduce(\"rbind\", lapply(hres, arrange_hres))) # Re-arrenge multi-step residuals in a matrix form mres <- res2matrix(hres_ct, agg_order = m)  cov_shr <- shrink_estim(na.omit(mres))   # Base forecasts' sample: base_ctg <- GMCM::rmvnormal(B, mu = res2matrix(base_mat, agg_order = m),                              sigma = as.matrix(cov_shr)) base_ctg <- apply(base_ctg, 1, function(x) matrix(x, ncol = NCOL(itagdp)), simplify = FALSE)  # Tip to speed up the time: B reconciliation to 1 reconciliation ctg_mlist <- lapply(base_ctjb, function(x) FoReco2matrix(t(x), agg_order = m)) ctg_list <- unlist(ctg_mlist, recursive=FALSE) id <- sort.int(factor(names(ctg_list), paste0(\"k-\", te_set), ordered = TRUE),                 index.return =TRUE)$ix base_ctg_mat <- t(Reduce(\"rbind\", ctg_list[id])) str(base_ctg_mat, give.attr = FALSE) #>  num [1:21, 1:700] 1715859 708966 1655955 1382431 281299 ...  # Reconciled forecasts' sample: reco_ctg <- ctrec(base = base_ctg_mat, agg_order = m, cons_mat = gdpconsmat,                    res = res_mat, comb = \"wlsv\") str(reco_ctg, give.attr = FALSE) #>  num [1:21, 1:700] 1755274 713842 1682939 1387490 295448 ..."},{"path":[]},{"path":"https://danigiro.github.io/FoReco/articles/Dataset-vndata-and-itagdp.html","id":"introduction","dir":"Articles","previous_headings":"","what":"Introduction","title":"The vndata and itagdp dataset","text":"Load packages:","code":"library(FoReco) # the datasets  # Plot and analysis library(ggplot2)  library(forecast)  library(gridExtra) library(reshape2)"},{"path":"https://danigiro.github.io/FoReco/articles/Dataset-vndata-and-itagdp.html","id":"vndata-groupped-monthly-time-series","dir":"Articles","previous_headings":"","what":"vndata: Groupped monthly time series","title":"The vndata and itagdp dataset","text":"Australian Tourism Demand cross-sectional temporal structure Australian Tourism Demand dataset (Girolimetto et al., 2024; Wickramasuriya et al., 2018) measures number nights Australians spent away home. includes 228 monthly observations Visitor Nights (VNs) January 1998 December 2016, cross-sectional grouped structure based geographic hierarchy crossed purpose travel. monthly bottom times series available robjhyndman.com/data/TourismData_v3.csv.  geographic hierarchy comprises 7 states, 27 zones, 76 regions, total 111 nested geographic divisions. Six zones formed single region, resulting 105 unique nodes hierarchy. purpose travel comprises four categories: holiday, visiting friends relatives, business, . avoid redundancies (Di Fonzo & Girolimetto, 2024), 24 nodes (6 zones formed single region) considered, resulting unbalanced hierarchy 525 unique nodes instead theoretical 555 duplicated nodes. data can temporally aggregated two, three, four, six, twelve months (\\(\\mathcal{K}=\\{12, 6, 4, 3, 2, 1\\}\\)). simple unbalanced hierarchy (left) balanced version (right). Source: Di Fonzo & Girolimetto (2024).","code":"# Dataset data(vndata)  str(vndata) #>  Time-Series [1:228, 1:525] from 1998 to 2017: 45151 17295 20725 25389 20330 ... #>  - attr(*, \"dimnames\")=List of 2 #>   ..$ : NULL #>   ..$ : chr [1:525] \"Total\" \"A\" \"B\" \"C\" ...  # Aggregation matrix data(vnaggmat) str(vnaggmat) #>  int [1:221, 1:304] 1 1 0 0 0 0 0 0 1 0 ... #>  - attr(*, \"dimnames\")=List of 2 #>   ..$ : chr [1:221] \"Total\" \"A\" \"B\" \"C\" ... #>   ..$ : chr [1:304] \"AAAHol\" \"AAAVis\" \"AAABus\" \"AAAOth\" ...  id_bts <- colnames(vnaggmat)[round(seq(1, NCOL(vnaggmat), length.out = 10))] states <- c(\"NSW\", \"VIC\", \"QLD\", \"SA\", \"WA\", \"TAS\", \"NT\") colnames(vndata)[colnames(vndata) %in% LETTERS[1:7]] <- states  marrangeGrob(list(autoplot(vndata[,\"Total\"], y = NULL,           main = \"Australia (total)\") + theme_minimal(), autoplot(vndata[, states], y = NULL,           main = \"States\") + theme_minimal(), autoplot(vndata[, c(\"Hol\", \"Vis\", \"Bus\", \"Oth\")], y = NULL,           main = \"Purpose of travel\") + theme_minimal(), autoplot(vndata[,id_bts], y = NULL,           main = \"Bottom time series\") + theme_minimal()),               top = NULL, nrow = 2, ncol = 2)"},{"path":"https://danigiro.github.io/FoReco/articles/Dataset-vndata-and-itagdp.html","id":"itagdp-general-linearly-constrained-multiple-quarterly-time-series","dir":"Articles","previous_headings":"","what":"itagdp: general linearly constrained multiple quarterly time series","title":"The vndata and itagdp dataset","text":"National Accounts coherent consistent set macroeconomic indicators used mostly economic research forecasting, policy design, coordination mechanisms. dataset, GDP key macroeconomic quantity measured using three main approaches, namely output (production), income expenditure. parallel systems internally present well-defned hierarchical structure variables relevant economic signifcance, Final consumption, expenditure side, Gross operating surplus mixed income income side, Total gross value added output side. EU countries, data processed basis ESA 2010 classifcation released Eurostat. dataset itagdp (https://ec.europa.eu/eurostat/web/national-accounts/) contains Italian Gross Domestic Product (GDP) current prices (euro), time series spanning period 2000:Q1-2019:Q4.  output, income expenditure approaches represented three differente hierarchies share top-level series (\\(GDP\\)), bottom-level series.  complete \\((9 \\times 21)\\) zero constraints matrix encompassing output, expenditure income sides represented following figure.  linear combination matrix general linearly constrained multiple time series may construct (Girolimetto & Di Fonzo, 2023).","code":"# Dataset data(itagdp)  str(itagdp) #>  Time-Series [1:80, 1:21] from 2000 to 2020: 290847 309761 301049 339856 307934 ... #>  - attr(*, \"dimnames\")=List of 2 #>   ..$ : NULL #>   ..$ : chr [1:21] \"GDP\" \"D1\" \"P3_P5\" \"P3\" ... autoplot(itagdp, y = NULL) + theme_minimal() plot_mat <- function(mat, font_size = 8, caption_label = NULL){     melt(mat) |>     ggplot(aes(x = Var2, y = Var1)) +      geom_tile(aes(fill=as.character(value)), color = \"grey\") +      scale_fill_manual(values = c(\"-1\" = \"red\", \"0\" = \"white\", \"1\" = \"black\")) +     labs(x=NULL, y=NULL, title=NULL) +     scale_y_discrete(limits=rev) +      scale_x_discrete(position = \"top\") +     labs(caption = caption_label) +     coord_fixed() +      theme_void() +     theme(axis.text.x=element_text(size=font_size, vjust=0.5, angle = 90, hjust=0),           axis.text.y=element_text(size=font_size, hjust=1),            plot.caption = element_text(size=rel(0.9), hjust=0.5, face = \"bold\"),           legend.position = \"none\")  } marrangeGrob(list(plot_mat(incside$agg_mat, caption_label = \"Income hierarchy\"),                   plot_mat(outside$agg_mat, caption_label = \"Output hierarchy\"),                    plot_mat(expside$agg_mat, caption_label = \"Expenditure hierarchy\")),               top = NULL, layout_matrix = matrix(c(1, 2, 3, 3, 3, 3, 3,3), 2, 4)) rownames(gdpconsmat)[c(1,2,4)] <- c(\"GDP[O]\", \"GDP[I]\", \"GDP[E]\") rownames(gdpconsmat)[-c(1,2,4)] <- colnames(gdpconsmat)[2:7]  plot_mat(gdpconsmat) obj <- lcmat(gdpconsmat)  A <- obj$agg_mat plot_mat(as.matrix(A), caption_label = \"Income, Output and Expenditure linear combination matrix\")"},{"path":[]},{"path":"https://danigiro.github.io/FoReco/articles/Replicate-the-hts-package.html","id":"introduction","dir":"Articles","previous_headings":"","what":"Introduction","title":"Replicate the hts package","text":"vignette, htseg2 dataset (simulated four level hierarchy total 17 series, length 16) hts package used show get results using FoReco.","code":"library(FoReco) library(hts)"},{"path":"https://danigiro.github.io/FoReco/articles/Replicate-the-hts-package.html","id":"base-forecasts","dir":"Articles","previous_headings":"","what":"Base forecasts","title":"Replicate the hts package","text":"","code":"data <- allts(htseg2) n <- NCOL(data) nb <- NCOL(htseg2$bts) na <- n-nb A <- smatrix(htseg2)[1:na, ] dimnames(A) <- list(colnames(data)[1:na], colnames(data)[-c(1:na)])  # List containing the base forecasts # Forecast horizon: 10 fc_obj <- list() for (i in 1:n) {   fc_obj[[i]] <- forecast(auto.arima(data[, i])) }  # Create the matrix of base forecasts base <- NULL for (i in 1:n) {   base <- cbind(base, fc_obj[[i]]$mean) } colnames(base) <- colnames(data)  # Create the matrix of residuals res <- NULL for (i in 1:n) {   res <- cbind(res, fc_obj[[i]]$residuals) } colnames(res) <- colnames(data)"},{"path":"https://danigiro.github.io/FoReco/articles/Replicate-the-hts-package.html","id":"comparisons","dir":"Articles","previous_headings":"","what":"Comparisons","title":"Replicate the hts package","text":"section compare reconciliation methods available hts FoReco packages show equivalence . explore bottom-, top-, optimal reconciliation approaches.","code":""},{"path":"https://danigiro.github.io/FoReco/articles/Replicate-the-hts-package.html","id":"bottom-up-and-top-down-reconciliation","dir":"Articles","previous_headings":"Comparisons","what":"Bottom-up and top-down reconciliation","title":"Replicate the hts package","text":"","code":"# Tollerance setting tol <- 1e-7  ## Bottom-up hts_bu <- forecast(htseg2, method = \"bu\", fmethod = \"arima\") FoReco_bu <- csbu(base[, colnames(A)], agg_mat = A) sum(abs(allts(hts_bu) - FoReco_bu) > tol) #> [1] 0  ## Top-down  ### Average historical proportions - Gross-Sohl method A hts_gsa <- forecast(htseg2, method = \"tdgsa\", fmethod = \"arima\") p_gsa <- colMeans(apply(htseg2$bts, 2, function(x) x/rowSums(htseg2$bts))) FoReco_gsa <- cstd(base[, 1], agg_mat = A, weights = p_gsa) sum(abs(allts(hts_gsa) - FoReco_gsa) > tol) #> [1] 0  ## Proportions of the historical averages - Gross-Sohl method F hts_gsf <- forecast(htseg2, method = \"tdgsf\", fmethod = \"arima\") p_gsf <- colMeans(htseg2$bts)/mean(rowSums(htseg2$bts)) FoReco_gsf <- cstd(base[, 1], agg_mat = A, weights = p_gsf) sum(abs(allts(hts_gsf) - FoReco_gsf) > tol) #> [1] 0  ### Forecast proportions hts_fp <- forecast(htseg2, method = \"tdfp\", fmethod = \"arima\") # FoReco needs the forecast proportions as input levels <- c(1, 2, 4, 10) S <- cstools(A)$strc_mat p_fp <- matrix(NA, nrow = NROW(base), ncol = NCOL(S)) for(i in 1:NROW(base)){   idl <- rep(1:length(levels), levels)   for(j in 1:NCOL(S)){     cs <- S[, j]     id2 <- rev(which(cs==1))     out <- NULL     for(k in 1:length(id2[-1])){       tmp <- S[which(idl == idl[id2[k]]-1), , drop = FALSE]       idf <- rowSums(S[idl == idl[id2[k]], tmp[tmp[,j]==1, ] == 1, drop = FALSE]) != 0       out <- c(out, base[i, id2[k]]/sum(sum(base[i, idl == idl[id2[k]]][idf])))     }     p_fp[i, j] <- prod(out)   } } FoReco_fp <- cstd(base[, 1], agg_mat = A, weights = p_fp, normalize = F) #> Warning: The `weights` do not add up to 1 sum(abs(allts(hts_fp) - FoReco_fp) > tol) #> [1] 0"},{"path":"https://danigiro.github.io/FoReco/articles/Replicate-the-hts-package.html","id":"optimal-forecast-reconciliation","dir":"Articles","previous_headings":"Comparisons","what":"Optimal forecast reconciliation","title":"Replicate the hts package","text":"","code":"## Ordinary least squares (identity error covariance matrix) hts_ols <- combinef(base, nodes = get_nodes(htseg2), keep = \"all\") FoReco_ols <- csrec(base, agg_mat = A, comb = \"ols\") sum(abs(hts_ols - FoReco_ols) > tol) #> [1] 0  ## Weighted least squares (structural variances) hts_str <- combinef(base, nodes = get_nodes(htseg2),                      weights = 1/apply(smatrix(htseg2), 1, sum),                      keep = \"all\") FoReco_str <- csrec(base, agg_mat = A, comb = \"str\") sum(abs(hts_str - FoReco_str) > tol) #> [1] 0  ## Generalized least squares (shrunk covariance matrix) hts_shr <- MinT(base, nodes = get_nodes(htseg2), keep = \"all\",                   covariance = \"shr\", residual = res) FoReco_shr <- csrec(base, agg_mat = A, comb = \"shr\", res = res) sum(abs(hts_shr - FoReco_shr) > tol) #> [1] 0  ## Generalized least squares (sample covariance matrix) hts_sam <- MinT(base, nodes = get_nodes(htseg2), keep = \"all\",                   covariance = \"sam\", residual = res) #> Warning in value[[3L]](cond): An error in LU decomposition occurred, the message was the following: #> 'a' is computationally singular, min(d)/max(d)=1.12144e-16, d=abs(diag(U)) #>  Trying QR decomposition instead... FoReco_sam <- csrec(base, agg_mat = A, comb = \"sam\", res = res) sum(abs(hts_sam-FoReco_sam) > tol) #> [1] 0"},{"path":"https://danigiro.github.io/FoReco/articles/Replicate-the-thief-package.html","id":"introduction","dir":"Articles","previous_headings":"","what":"Introduction","title":"Replicate the thief package","text":"dataset thief package used show get results FoReco package. particular, take weekly data Accident Emergency demand UK, AEdemand, 1 January 2011 31 December 2014.","code":"library(FoReco) library(thief)  extract_thief <- function(x){   out <- NULL   for(i in length(x):1) {     out <- c(out, x[[i]]$mean)   }   return(out) }"},{"path":"https://danigiro.github.io/FoReco/articles/Replicate-the-thief-package.html","id":"base-forecasts","dir":"Articles","previous_headings":"","what":"Base forecasts","title":"Replicate the thief package","text":"","code":"dataset <- window(AEdemand[, 12], start = c(2011, 1), end = c(2014, 52)) data <- tsaggregates(dataset) # Base forecasts fc_obj <- list() for (i in 1:5) {   fc_obj[[i]] <- forecast(auto.arima(data[[i]])) } fc_obj[[6]] <- forecast(auto.arima(data[[6]]), h = 2) # Base forecasts vector base <- NULL for (i in 6:1) {   base <- c(base, fc_obj[[i]]$mean) } # Residual vector res <- NULL for (i in 6:1) {   res <- c(res, fc_obj[[i]]$residuals) }"},{"path":"https://danigiro.github.io/FoReco/articles/Replicate-the-thief-package.html","id":"comparisons","dir":"Articles","previous_headings":"","what":"Comparisons","title":"Replicate the thief package","text":"","code":"# Tollerance setting tol <- 1e-7  ## Bottom-up thief_bu <- reconcilethief(fc_obj, comb=\"bu\") FoReco_bu <- tebu(fc_obj[[1]]$mean, agg_order = 52) sum(abs(FoReco_bu - extract_thief(thief_bu)) > 1e-10) #> [1] 0  ## Ordinary least squares (identity error covariance matrix) thief_ols <- reconcilethief(fc_obj, comb=\"ols\") FoReco_ols <- terec(base, 52, comb = \"ols\") sum(abs(FoReco_ols - extract_thief(thief_ols)) > 1e-10) #> [1] 0  ## Weighted least squares (structural variances) thief_str <- reconcilethief(fc_obj, comb=\"struc\") FoReco_str <- terec(base, 52, comb = \"str\") sum(abs(FoReco_str - extract_thief(thief_str)) > 1e-10) #> [1] 0  ## Generalized least squares (shrunk covariance matrix) thief_shr <- reconcilethief(fc_obj, comb=\"shr\") FoReco_shr <- terec(base, 52, comb = \"shr\", res = res) sum(abs(FoReco_shr - extract_thief(thief_shr)) > 1e-10) #> [1] 0"},{"path":"https://danigiro.github.io/FoReco/articles/Temporal-forecast-reconciliation.html","id":"introduction","dir":"Articles","previous_headings":"","what":"Introduction","title":"Temporal forecast reconciliation","text":"vignette, explore process temporal reconciliation using FoReco package, focus Capital Country monthly time series (ADB) vndata dataset (Wickramasuriya et al., 2018). Temporal reconciliation method used ensure forecasts coherent across different time periods, providing consistent view high-frequency (e.g., monthly) aggregated levels (e.g., yearly). first obtain base forecasts using ETS model log transformation proceed several reconciliation methods: bottom-, top-, optimal combination. method strengths practical challenges, ensuring non-negativity incorporating priori constraints.","code":""},{"path":"https://danigiro.github.io/FoReco/articles/Temporal-forecast-reconciliation.html","id":"packages","dir":"Articles","previous_headings":"Introduction","what":"Packages","title":"Temporal forecast reconciliation","text":"First, load necessary packages.","code":"library(FoReco)   # -> To perform reconciliation library(forecast)  # -> To obtain base forecasts"},{"path":"https://danigiro.github.io/FoReco/articles/Temporal-forecast-reconciliation.html","id":"capital-country-monthly-time-series","dir":"Articles","previous_headings":"","what":"Capital Country monthly time series","title":"Temporal forecast reconciliation","text":"temporal framework, working single series. particular vignette consider Capital Country monthly time series (ADB) vndata dataset (Wickramasuriya et al., 2018). See dataset vignette details.","code":"data(vndata)      # dataset y <- vndata[, \"GBDOth\"] te_set <- tetools(12)$set m <- max(te_set)"},{"path":"https://danigiro.github.io/FoReco/articles/Temporal-forecast-reconciliation.html","id":"base-forecast","dir":"Articles","previous_headings":"Capital Country monthly time series","what":"Base Forecast","title":"Temporal forecast reconciliation","text":"obtained base forecasts, fit ETS model log transformation. obtain twelve-, six-, four-, three-, two-, one-step-ahead base forecasts monthly data aggregation 2, 3, 4, 6, 12 months. extract point forecasts residuals fitted models.","code":"data_k <- aggts(y, te_set) model <- setNames(vector(mode='list', length=length(te_set)), paste0(\"k-\", te_set)) fc_obj <- setNames(vector(mode='list', length=length(te_set)), paste0(\"k-\", te_set))  # ETS model with log transformation ets_log <- function(x, ...){   x[x==0] <- min(x[x!=0])/2   ets(x, lambda = 0, ...) }  for(k in te_set){   model[[paste0(\"k-\", k)]] <- ets_log(data_k[[paste0(\"k-\", k)]])   fc_obj[[paste0(\"k-\", k)]] <- forecast(model[[paste0(\"k-\", k)]], h = m/k) } # Point forecasts base <- lapply(fc_obj, function(x) x$mean) str(base, give.attr = FALSE) #> List of 6 #>  $ k-12: Time-Series [1:1] from 2017 to 2017: 1.31 #>  $ k-6 : Time-Series [1:2] from 2017 to 2018: 0.557 0.557 #>  $ k-4 : Time-Series [1:3] from 2017 to 2018: 0.356 0.356 0.356 #>  $ k-3 : Time-Series [1:4] from 2017 to 2018: 0.243 0.243 0.243 0.243 #>  $ k-2 : Time-Series [1:6] from 2017 to 2018: 0.225 0.225 0.225 0.225 0.225 ... #>  $ k-1 : Time-Series [1:12] from 2017 to 2018: 0.178 0.178 0.178 0.178 0.178 ... # Residuals res <- lapply(fc_obj, residuals, type = \"response\") str(res, give.attr = FALSE) #> List of 6 #>  $ k-12: Time-Series [1:19] from 1998 to 2016: 18.15 -1.18 1.13 31.64 13.37 ... #>  $ k-6 : Time-Series [1:38] from 1998 to 2016: -0.422 18.911 -0.422 -0.422 -0.422 ... #>  $ k-4 : Time-Series [1:57] from 1998 to 2017: -0.221 14.333 4.423 -0.221 -0.221 ... #>  $ k-3 : Time-Series [1:76] from 1998 to 2017: -0.243 -0.228 14.338 4.377 -0.306 ... #>  $ k-2 : Time-Series [1:114] from 1998 to 2017: -0.0904 -0.0904 -0.0904 14.4633 -0.0905 ... #>  $ k-1 : Time-Series [1:228] from 1998 to 2017: -0.0433 -0.0433 -0.0433 -0.0433 -0.0433 ..."},{"path":"https://danigiro.github.io/FoReco/articles/Temporal-forecast-reconciliation.html","id":"point-reconciliation","dir":"Articles","previous_headings":"Capital Country monthly time series","what":"Point Reconciliation","title":"Temporal forecast reconciliation","text":"Bottom-reconciliation (Dunn et al., 1976) aggregates high-frequency forecasts monthly level higher temporal levels (Girolimetto et al., 2024). obtain list forecasts different orders aggregation, can use FoReco2matrix function. top-reconciliation hierarchical time series, forecast annual series (\\(k = 12\\)) distributed proportionally ensure top-level value stays bottom-level forecasts non-negative (Gross & Sohl, 1990). perform temporal reconciliation FoReco using base forecasts temporal aggregation order, necessary arrange base forecasts (residuals) vector form. level conditional coherent reconciliation (LCC) generalization original proposal Hollyman et al. (2021) Di Fonzo & Girolimetto (2024) include temporal framework. Finally can obtained optimal (least squares sense) combination temporal reconciled forecast (Athanasopoulos et al., 2017). following table shows options optimal combination temporal reconciliation function terec().","code":"fc_bts <- base$`k-1` rf_bu <- tebu(fc_bts, agg_order = m) str(rf_bu, give.attr = FALSE) #>  Named num [1:28] 2.137 1.069 1.069 0.712 0.712 ... str(FoReco2matrix(rf_bu), give.attr=FALSE) #> List of 6 #>  $ k-12: num 2.14 #>  $ k-6 : num [1:2] 1.07 1.07 #>  $ k-4 : num [1:3] 0.712 0.712 0.712 #>  $ k-3 : num [1:4] 0.534 0.534 0.534 0.534 #>  $ k-2 : num [1:6] 0.356 0.356 0.356 0.356 0.356 ... #>  $ k-1 : num [1:12] 0.178 0.178 0.178 0.178 0.178 ... y_mat <- matrix(data_k$`k-1`, ncol = m, byrow = TRUE) x12 <- data_k$`k-12` fc_x12 <- base$`k-12`  # Average historical proportions - Gross-Sohl method A p_gsa <- colMeans(apply(y_mat, 2, function(x) x/x12), na.rm = TRUE) rf_td_gsa <- tetd(fc_x12, agg_order = m, weights = p_gsa) str(rf_td_gsa, give.attr = FALSE) #>  Named num [1:28] 1.314 0.497 0.818 0.216 0.791 ...  # Proportions of the historical averages - Gross-Sohl method F p_gsf <- colMeans(y_mat)/mean(x12) rf_td_gsf <- tetd(fc_x12, agg_order = m, weights = p_gsf) str(rf_td_gsf, give.attr = FALSE) #>  Named num [1:28] 1.314 0.501 0.813 0.079 0.99 ... base_vec <- unlist(base, use.names = FALSE) res_vec <- unlist(res, use.names = FALSE) rf_lcc <- telcc(base = base_vec, agg_order = m,                 res = res_vec, comb = \"wlsv\") str(rf_lcc, give.attr = FALSE) #>  Named num [1:28] 1.326 0.663 0.663 0.442 0.442 ... rf_opt <- terec(base = base_vec, agg_order = m,                 res = res_vec, comb = \"sar1\") str(rf_opt, give.attr = FALSE) #>  Named num [1:28] 1.329 0.665 0.665 0.443 0.443 ..."},{"path":[]},{"path":"https://danigiro.github.io/FoReco/articles/Temporal-forecast-reconciliation.html","id":"non-negativity-issues","dir":"Articles","previous_headings":"Capital Country monthly time series > Practical challenges","what":"Non negativity issues","title":"Temporal forecast reconciliation","text":"always true reconciled forecasts remain non-negative even base forecasts non-negative. example, consider case shrinkage covariance matrix (\"shr\"). address issue, can use two approaches: State---art numerical optimization procedure, osqp (Stellato et al., 2020). Simple heuristic strategy: set-negative--zero, sntz (Di Fonzo & Girolimetto, 2023).","code":"rf_opt_shr <- terec(base = base_vec, agg_order = m,                     res = res_vec, comb = \"shr\") recoinfo(rf_opt_shr) #> ✔ Optimal Temporal Forecast Reconciliation #> ℹ FoReco function: `terec` #> ℹ Covariance approximation: `shr` #> ℹ Non-negative forecasts: `FALSE` rf_osqp <- terec(base = base_vec, agg_order = m,                 res = res_vec, comb = \"shr\", nn = \"osqp\") tmp <- recoinfo(rf_osqp) #> ✔ Optimal Temporal Forecast Reconciliation #> ℹ FoReco function: `terec` #> ℹ Covariance approximation: `shr` #> ℹ Non-negative forecasts: `TRUE` tmp$info # OSQP information matrix  #>     obj_val    run_time iter      pri_res status status_polish #> 1 -16.58821 0.000280082   50 5.551115e-17      1             1 rf_sntz <- terec(base = base_vec, agg_order = m,                 res = res_vec, comb = \"shr\", nn = \"sntz\") recoinfo(rf_sntz) #> ✔ Optimal Temporal Forecast Reconciliation #> ℹ FoReco function: `terec` #> ℹ Covariance approximation: `shr` #> ℹ Non-negative forecasts: `TRUE`"},{"path":"https://danigiro.github.io/FoReco/articles/Temporal-forecast-reconciliation.html","id":"a-priori-constrained-immutable-forecasts","dir":"Articles","previous_headings":"Capital Country monthly time series > Practical challenges","what":"A priori constrained (immutable) forecasts","title":"Temporal forecast reconciliation","text":"Sometimes may wish incorporate priori knowledge reconciliation process (Zhang et al., 2023) order improve accuracy reconciled forecasts. example, suppose want fix forecasts annual level base forecasts values.","code":"rf_imm <- terec(base = base_vec, agg_order = m,                 res = res_vec, comb = \"sar1\", immutable = rbind(c(12,1))) str(rf_imm, give.attr = FALSE) #>  Named num [1:28] 1.314 0.657 0.657 0.438 0.438 ... rf_imm[1] - base_vec[1] #> k-12 h-1  #>        0"},{"path":"https://danigiro.github.io/FoReco/articles/Temporal-forecast-reconciliation.html","id":"exploring-a-subset-of-temporal-aggregation-orders","dir":"Articles","previous_headings":"Capital Country monthly time series > Practical challenges","what":"Exploring a subset of temporal aggregation orders","title":"Temporal forecast reconciliation","text":"approaches far involved considering factors \\(m\\) potential aggregation orders. Nevertheless, worth noting also focus given subset factors. example, interested monthly, quarterly annual forecasts.","code":"te_subset <- c(12, 3, 1) base_vec2 <- unlist(base[paste0(\"k-\", te_subset)], use.names = FALSE) res_vec2 <- unlist(res[paste0(\"k-\", te_subset)], use.names = FALSE) rf_sub <- terec(base = base_vec2, agg_order = te_subset,                 res = res_vec2, comb = \"sar1\") str(rf_sub, give.attr = FALSE) #>  Named num [1:17] 1.48 0.371 0.369 0.369 0.371 ..."},{"path":"https://danigiro.github.io/FoReco/articles/Temporal-forecast-reconciliation.html","id":"probabilistic-reconciliation","dir":"Articles","previous_headings":"Capital Country monthly time series","what":"Probabilistic Reconciliation","title":"Temporal forecast reconciliation","text":"Following Panagiotelis et al. (2023) Girolimetto et al. (2024), reconciliation probabilistic forecasts two-step process: first, sample incoherent distributio, reconcile sample. can use non-parametric method, joint block bootstrap simulate \\(B\\) samples reconciled . parametric method assumes normal distribution (Gaussian) generate incoherent sample set forecasts.","code":"# Base forecasts' sample: # we simulate from the base models by sampling errors  # while keeping the cross-sectional dimension fixed. B <- 100 base_tejb <- teboot(model, B, m)$sample dim(base_tejb) #> [1] 100  28 # Reconciled forecasts' sample:  # we reconcile each member of a sample from the incoherent distribution. reco_tejb <- t(apply(base_tejb, 1, terec, agg_order = m, res = res_vec, nn = \"sntz\",                    comb = \"sar1\")) str(reco_tejb, give.attr = FALSE) #>  num [1:100, 1:28] 18.293 0.608 2.808 0.627 18.293 ... # Multi-step residuals hres <- lapply(model, function(fit)   lapply(1:frequency(fit$x), function(h) residuals(fit, type='response', h = h))) hres <- Reduce(\"c\", lapply(hres, arrange_hres)) # Re-arrenge multi-step residuals in a matrix form mres <- res2matrix(hres, agg_order = m)  base_teg <- MASS::mvrnorm(n = B, mu = base_vec, Sigma = shrink_estim(mres)) str(base_teg, give.attr = FALSE) #>  num [1:100, 1:28] 0.714 -10.105 8.384 -0.327 -3.272 ...  reco_teg <- t(apply(base_teg, 1, terec, agg_order = m, res = res_vec, nn = \"sntz\",                    comb = \"sar1\")) str(reco_teg, give.attr = FALSE) #>  num [1:100, 1:28] 16.62 4.95 18.48 16.02 4.13 ..."},{"path":[]},{"path":"https://danigiro.github.io/FoReco/authors.html","id":null,"dir":"","previous_headings":"","what":"Authors","title":"Authors and Citation","text":"Daniele Girolimetto. Author, maintainer, funder. Tommaso Di Fonzo. Author, funder.","code":""},{"path":"https://danigiro.github.io/FoReco/authors.html","id":"citation","dir":"","previous_headings":"","what":"Citation","title":"Authors and Citation","text":"Girolimetto D, Di Fonzo T (2024). FoReco: Forecast Reconciliation. R package version 1.0. doi:10.32614/CRAN.package.FoReco, https://cran.r-project.org/package=FoReco. Di Fonzo T, Girolimetto D (2023). “Cross-temporal forecast reconciliation: Optimal combination method heuristic alternatives.” International Journal Forecasting, 39(1), 134. doi:10.1016/j.ijforecast.2021.08.004. Girolimetto D, Athanasopoulos G, Di Fonzo T, Hyndman R (2024). “Cross-temporal probabilistic forecast reconciliation: Methodological practical issues.” International Journal Forecasting, 40(3), 2285. doi:10.1016/j.ijforecast.2023.10.003.","code":"@Manual{,   title = {FoReco: Forecast Reconciliation},   author = {Daniele Girolimetto and Tommaso {Di Fonzo}},   organization = {R package version 1.0},   year = {2024},   doi = {10.32614/CRAN.package.FoReco},   url = {https://cran.r-project.org/package=FoReco}, } @Article{,   title = {Cross-temporal forecast reconciliation: Optimal combination method and heuristic alternatives},   author = {Tommaso {Di Fonzo} and Daniele Girolimetto},   journal = {International Journal of Forecasting},   volume = {39},   year = {2023},   number = {1},   pages = {134},   doi = {10.1016/j.ijforecast.2021.08.004}, } @Article{,   title = {Cross-temporal probabilistic forecast reconciliation: Methodological and practical issues},   author = {Daniele Girolimetto and George Athanasopoulos and Tommaso {Di Fonzo} and Rob J Hyndman},   journal = {International Journal of Forecasting},   volume = {40},   year = {2024},   number = {3},   pages = {2285},   doi = {10.1016/j.ijforecast.2023.10.003}, }"},{"path":"https://danigiro.github.io/FoReco/index.html","id":"foreco-","dir":"","previous_headings":"","what":"Forecast Reconciliation","title":"Forecast Reconciliation","text":"Forecast Reconciliation post-forecasting process aimed improve accuracy align forecasts system linearly constrained (e.g. hierarchical/grouped) time series. FoReco package provides comprehensive set classical (bottom-, top-middle-), modern (optimal heuristic combination) forecast reconciliation procedures different frameworks including cross-sectional, temporal, cross-temporal settings. core functions reconciliation categorized framework follows: Additionally, FoReco provides various functions different aspects forecast reconciliation, including aggregating time series, balancing hierarchies, computing projection covariance matrices, .","code":""},{"path":"https://danigiro.github.io/FoReco/index.html","id":"installation","dir":"","previous_headings":"","what":"Installation","title":"Forecast Reconciliation","text":"can install stable version R CRAN can also install development version Github","code":"install.packages(\"FoReco\") # install.packages(\"devtools\") devtools::install_github(\"danigiro/FoReco\")"},{"path":"https://danigiro.github.io/FoReco/index.html","id":"getting-started","dir":"","previous_headings":"","what":"Getting Started","title":"Forecast Reconciliation","text":"get started using FoReco package, refer documentation detailed information apply different forecast reconciliation procedures data. vndata itagdp dataset Cross-sectional forecast reconciliation Temporal forecast reconciliation Cross-temporal forecast reconciliation Replicate hts package Replicate thief package","code":""},{"path":"https://danigiro.github.io/FoReco/index.html","id":"issues-and-contributions","dir":"","previous_headings":"","what":"Issues and Contributions","title":"Forecast Reconciliation","text":"encounter bugs suggestions improvements, please feel free report GitHub Issues page. Contributions also welcome!","code":""},{"path":"https://danigiro.github.io/FoReco/reference/FoReco-package.html","id":null,"dir":"Reference","previous_headings":"","what":"FoReco: Forecast Reconciliation — FoReco-package","title":"FoReco: Forecast Reconciliation — FoReco-package","text":"Classical (bottom-top-), optimal combination heuristic point (Di Fonzo Girolimetto, 2023 doi:10.1016/j.ijforecast.2021.08.004 ) probabilistic (Girolimetto et al. 2023 doi:10.1016/j.ijforecast.2023.10.003 ) forecast reconciliation procedures linearly constrained time series (e.g., hierarchical grouped time series) cross-sectional, temporal, cross-temporal frameworks.","code":""},{"path":[]},{"path":"https://danigiro.github.io/FoReco/reference/FoReco-package.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"FoReco: Forecast Reconciliation — FoReco-package","text":"Maintainer: Daniele Girolimetto daniele.girolimetto@unipd.(ORCID) [funder] Authors: Tommaso Di Fonzo (ORCID) [funder]","code":""},{"path":"https://danigiro.github.io/FoReco/reference/FoReco2matrix.html","id":null,"dir":"Reference","previous_headings":"","what":"Reconciled forecasts to matrix/vector — FoReco2matrix","title":"Reconciled forecasts to matrix/vector — FoReco2matrix","text":"function splits temporal vectors cross-temporal matrices list according temporal aggregation order","code":""},{"path":"https://danigiro.github.io/FoReco/reference/FoReco2matrix.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Reconciled forecasts to matrix/vector — FoReco2matrix","text":"","code":"FoReco2matrix(x, agg_order, keep_names = FALSE)"},{"path":"https://danigiro.github.io/FoReco/reference/FoReco2matrix.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Reconciled forecasts to matrix/vector — FoReco2matrix","text":"x output reconciliation function implemented FoReco. agg_order Highest available sampling frequency per seasonal cycle (max. order temporal aggregation, \\(m\\)), vector representing subset \\(p\\) factors \\(m\\). keep_names FALSE (default), rownames names output matrices removed.","code":""},{"path":"https://danigiro.github.io/FoReco/reference/FoReco2matrix.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Reconciled forecasts to matrix/vector — FoReco2matrix","text":"list matrices vectors distinct temporal aggregation order.","code":""},{"path":[]},{"path":"https://danigiro.github.io/FoReco/reference/FoReco2matrix.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Reconciled forecasts to matrix/vector — FoReco2matrix","text":"","code":"set.seed(123) # (3 x 7) base forecasts matrix (simulated), Z = X + Y and m = 4 base <- rbind(rnorm(7, rep(c(20, 10, 5), c(1, 2, 4))),               rnorm(7, rep(c(10, 5, 2.5), c(1, 2, 4))),               rnorm(7, rep(c(10, 5, 2.5), c(1, 2, 4))))  reco <- ctrec(base = base, agg_mat = t(c(1,1)), agg_order = 4, comb = \"ols\") matrix_list <- FoReco2matrix(reco)"},{"path":"https://danigiro.github.io/FoReco/reference/aggts.html","id":null,"dir":"Reference","previous_headings":"","what":"Non-overlapping temporal aggregation of a time series — aggts","title":"Non-overlapping temporal aggregation of a time series — aggts","text":"Non-overlapping temporal aggregation time series according specific aggregation order.","code":""},{"path":"https://danigiro.github.io/FoReco/reference/aggts.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Non-overlapping temporal aggregation of a time series — aggts","text":"","code":"aggts(y, agg_order, tew = \"sum\", align = \"end\", rm_na = FALSE)"},{"path":"https://danigiro.github.io/FoReco/reference/aggts.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Non-overlapping temporal aggregation of a time series — aggts","text":"y Univariate multivariate time series: vector/matrix ts object. agg_order numeric vector aggregation orders consider. tew string specifying type temporal aggregation. Options include: \"sum\" (simple summation, default), \"avg\" (average), \"first\" (first value period), \"last\" (last value period). align string vector specifying alignment y. Options include: \"end\" (end series, default), \"start\" (start series), integer (vector integers) indicating starting period temporally aggregated series. rm_na TRUE missing values removed.","code":""},{"path":"https://danigiro.github.io/FoReco/reference/aggts.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Non-overlapping temporal aggregation of a time series — aggts","text":"list vectors ts objects.","code":""},{"path":[]},{"path":"https://danigiro.github.io/FoReco/reference/aggts.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Non-overlapping temporal aggregation of a time series — aggts","text":"","code":"# Monthly time series (input vector) y <- ts(rnorm(24), start = 2020, frequency = 12) # Quarterly time series x1 <- aggts(y, 3) # Monthly, quarterly and annual time series x2 <- aggts(y, c(1, 3, 12)) # All temporally aggregated time series x3 <- aggts(y)  # Ragged data y2 <- ts(rnorm(11), start = c(2020, 3), frequency = 4) # Annual time series: start in 2021 x4 <- aggts(y2, 4, align = 3) # Semi-annual (start in 2nd semester of 2020) and annual (start in 2021) time series x5 <- aggts(y2, c(2, 4), align = c(1, 3))"},{"path":"https://danigiro.github.io/FoReco/reference/balance_hierarchy.html","id":null,"dir":"Reference","previous_headings":"","what":"Aggregation matrix of a (possibly) unbalanced hierarchy in balanced form — balance_hierarchy","title":"Aggregation matrix of a (possibly) unbalanced hierarchy in balanced form — balance_hierarchy","text":"hierarchy \\(L\\) upper levels said balanced variable level \\(l\\) least one child level \\(l+1\\). hold, hierarchy unbalanced. function transforms aggregation matrix unbalanced hierarchy aggregation matrix balanced one. function used reconcile forecasts cslcc, operates exclusively balanced hierarchies.","code":""},{"path":"https://danigiro.github.io/FoReco/reference/balance_hierarchy.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Aggregation matrix of a (possibly) unbalanced hierarchy in balanced form — balance_hierarchy","text":"","code":"balance_hierarchy(agg_mat, nodes = \"auto\", sparse = TRUE)"},{"path":"https://danigiro.github.io/FoReco/reference/balance_hierarchy.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Aggregation matrix of a (possibly) unbalanced hierarchy in balanced form — balance_hierarchy","text":"agg_mat (\\(n_a \\times n_b\\)) numeric matrix representing cross-sectional aggregation matrix. maps \\(n_b\\) bottom-level (free) variables \\(n_a\\) upper (constrained) variables. nodes (\\(L \\times 1\\)) numeric vector indicating number variables upper \\(L\\) levels hierarchy. default value string \"auto\" calculates number variables level. sparse Option return sparse matrices (default TRUE).","code":""},{"path":"https://danigiro.github.io/FoReco/reference/balance_hierarchy.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Aggregation matrix of a (possibly) unbalanced hierarchy in balanced form — balance_hierarchy","text":"list containing four elements: bam balanced aggregation matrix. agg_mat input matrix. nodes (\\(L \\times 1\\)) numeric vector indicating number variables \\(L\\) upper levels balanced hierarchy. id identification number variable balanced hierarchy. may contains duplicated values.","code":""},{"path":[]},{"path":"https://danigiro.github.io/FoReco/reference/balance_hierarchy.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Aggregation matrix of a (possibly) unbalanced hierarchy in balanced form — balance_hierarchy","text":"","code":"#    Unbalanced     ->      Balanced #        T                     T #    |-------|             |-------| #    A       |             A       B #  |---|     |           |---|     | # AA   AB    B          AA   AB    BA A <- matrix(c(1, 1, 1,               1, 1, 0), 2, byrow = TRUE) obj <- balance_hierarchy(agg_mat = A, nodes = c(1, 1)) obj$bam #> 3 x 3 sparse Matrix of class \"dgCMatrix\" #>            #> [1,] 1 1 1 #> [2,] 1 1 . #> [3,] . . 1"},{"path":"https://danigiro.github.io/FoReco/reference/commat.html","id":null,"dir":"Reference","previous_headings":"","what":"Commutation matrix — commat","title":"Commutation matrix — commat","text":"function returns (\\(r c \\times r c\\)) commutation matrix \\(\\mathbf{P}\\) \\(\\mathbf{P} \\mbox{vec}(\\mathbf{Y}) = \\mbox{vec}(\\mathbf{Y}'),\\) \\(\\mathbf{Y}\\) (\\(r \\times c\\)) matrix (Magnus Neudecker, 2019).","code":""},{"path":"https://danigiro.github.io/FoReco/reference/commat.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Commutation matrix — commat","text":"","code":"commat(r, c)"},{"path":"https://danigiro.github.io/FoReco/reference/commat.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Commutation matrix — commat","text":"r Number rows \\(\\mathbf{Y}\\). c Number columns \\(\\mathbf{Y}\\).","code":""},{"path":"https://danigiro.github.io/FoReco/reference/commat.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Commutation matrix — commat","text":"sparse (\\(r c \\times r c\\)) matrix, \\(\\mathbf{P}\\).","code":""},{"path":"https://danigiro.github.io/FoReco/reference/commat.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Commutation matrix — commat","text":"Magnus, J.R. Neudecker, H. (2019), Matrix Differential Calculus Applications Statistics Econometrics, third edition, New York, Wiley, pp. 54-55.","code":""},{"path":[]},{"path":"https://danigiro.github.io/FoReco/reference/commat.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Commutation matrix — commat","text":"","code":"Y <- matrix(rnorm(30), 5, 6) P <- commat(5, 6) P %*% as.vector(Y) == as.vector(t(Y)) # check #> 30 x 1 Matrix of class \"lgeMatrix\" #>       [,1] #>  [1,] TRUE #>  [2,] TRUE #>  [3,] TRUE #>  [4,] TRUE #>  [5,] TRUE #>  [6,] TRUE #>  [7,] TRUE #>  [8,] TRUE #>  [9,] TRUE #> [10,] TRUE #> [11,] TRUE #> [12,] TRUE #> [13,] TRUE #> [14,] TRUE #> [15,] TRUE #> [16,] TRUE #> [17,] TRUE #> [18,] TRUE #> [19,] TRUE #> [20,] TRUE #> [21,] TRUE #> [22,] TRUE #> [23,] TRUE #> [24,] TRUE #> [25,] TRUE #> [26,] TRUE #> [27,] TRUE #> [28,] TRUE #> [29,] TRUE #> [30,] TRUE"},{"path":"https://danigiro.github.io/FoReco/reference/csboot.html","id":null,"dir":"Reference","previous_headings":"","what":"Cross-sectional joint block bootstrap — csboot","title":"Cross-sectional joint block bootstrap — csboot","text":"Joint block bootstrap generating probabilistic base forecasts take account correlation different time series (Panagiotelis et al. 2023).","code":""},{"path":"https://danigiro.github.io/FoReco/reference/csboot.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Cross-sectional joint block bootstrap — csboot","text":"","code":"csboot(model_list, boot_size, block_size, seed = NULL)"},{"path":"https://danigiro.github.io/FoReco/reference/csboot.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Cross-sectional joint block bootstrap — csboot","text":"model_list list \\(n\\) base forecasts models. simulate() function model available implemented according package forecast, following mandatory parameters: object, innov, future, nsim. boot_size number bootstrap replicates. block_size Block size bootstrap, typically equivalent forecast horizon. seed integer seed.","code":""},{"path":"https://danigiro.github.io/FoReco/reference/csboot.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Cross-sectional joint block bootstrap — csboot","text":"list two elements: seed used sample errors 3-d array (\\(\\text{boot\\_size}\\times n \\times \\text{block\\_size}\\)).","code":""},{"path":"https://danigiro.github.io/FoReco/reference/csboot.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Cross-sectional joint block bootstrap — csboot","text":"Panagiotelis, ., Gamakumara, P., Athanasopoulos, G. Hyndman, R.J. (2023), Probabilistic forecast reconciliation: Properties, evaluation score optimisation, European Journal Operational Research 306(2), 693–706. doi:10.1016/j.ejor.2022.07.040","code":""},{"path":[]},{"path":"https://danigiro.github.io/FoReco/reference/csbu.html","id":null,"dir":"Reference","previous_headings":"","what":"Cross-sectional bottom-up reconciliation — csbu","title":"Cross-sectional bottom-up reconciliation — csbu","text":"function computes cross-sectional bottom-reconciled forecasts (Dunn et al., 1976) series appropriate summation bottom base forecasts \\(\\widehat{\\mathbf{b}}\\): $$\\widetilde{\\mathbf{y}} = \\mathbf{S}_{cs}\\widehat{\\mathbf{b}},$$ \\(\\mathbf{S}_{cs}\\) cross-sectional structural matrix.","code":""},{"path":"https://danigiro.github.io/FoReco/reference/csbu.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Cross-sectional bottom-up reconciliation — csbu","text":"","code":"csbu(base, agg_mat, sntz = FALSE)"},{"path":"https://danigiro.github.io/FoReco/reference/csbu.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Cross-sectional bottom-up reconciliation — csbu","text":"base (\\(h \\times n_b\\)) numeric matrix multivariate time series (mts class) containing bottom base forecasts; \\(h\\) forecast horizon, \\(n_b\\) total number bottom variables. agg_mat (\\(n_a \\times n_b\\)) numeric matrix representing cross-sectional aggregation matrix. maps \\(n_b\\) bottom-level (free) variables \\(n_a\\) upper (constrained) variables. sntz TRUE, negative base forecasts set zero applying bottom-.","code":""},{"path":"https://danigiro.github.io/FoReco/reference/csbu.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Cross-sectional bottom-up reconciliation — csbu","text":"(\\(h \\times n\\)) numeric matrix cross-sectional reconciled forecasts.","code":""},{"path":"https://danigiro.github.io/FoReco/reference/csbu.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Cross-sectional bottom-up reconciliation — csbu","text":"Dunn, D. M., Williams, W. H. Dechaine, T. L. (1976), Aggregate versus subaggregate models local area forecasting, Journal American Statistical Association 71(353), 68–71. doi:10.1080/01621459.1976.10481478","code":""},{"path":[]},{"path":"https://danigiro.github.io/FoReco/reference/csbu.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Cross-sectional bottom-up reconciliation — csbu","text":"","code":"set.seed(123) # (3 x 2) bottom base forecasts matrix (simulated), Z = X + Y bts <- matrix(rnorm(6, mean = c(10, 10)), 3, byrow = TRUE)  # Aggregation matrix for Z = X + Y A <- t(c(1,1)) reco <- csbu(base = bts, agg_mat = A)  # Non negative reconciliation bts[2,2] <- -bts[2,2] # Making negative one of the base forecasts for variable Y nnreco <- csbu(base = bts, agg_mat = A, sntz = TRUE)"},{"path":"https://danigiro.github.io/FoReco/reference/cscov.html","id":null,"dir":"Reference","previous_headings":"","what":"Cross-sectional covariance matrix approximation — cscov","title":"Cross-sectional covariance matrix approximation — cscov","text":"function provides approximation cross-sectional base forecasts errors covariance matrix using different reconciliation methods (see Wickramasuriya et al., 2019 Di Fonzo Girolimetto, 2023).","code":""},{"path":"https://danigiro.github.io/FoReco/reference/cscov.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Cross-sectional covariance matrix approximation — cscov","text":"","code":"cscov(comb = \"ols\", n = NULL, agg_mat = NULL, res, mse = TRUE,       shrink_fun = shrink_estim, ...)"},{"path":"https://danigiro.github.io/FoReco/reference/cscov.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Cross-sectional covariance matrix approximation — cscov","text":"comb string specifying reconciliation method. Ordinary least squares: \"ols\" (default) - identity error covariance matrix. Weighted least squares: \"str\" - structural variances. \"wls\" - series variances (uses res). Generalized least squares: \"shr\"/\"sam\" - shrunk/sample covariance (uses res). n Number variables (\\(n = n_a + n_b\\)). agg_mat (\\(n_a \\times n_b\\)) numeric matrix representing cross-sectional aggregation matrix. maps \\(n_b\\) bottom-level (free) variables \\(n_a\\) upper (constrained) variables. res (\\(N \\times n\\)) optional numeric matrix containing -sample residuals. matrix used compute covariance matrices. mse TRUE (default) residuals used compute covariance matrix mean-corrected. shrink_fun Shrinkage function covariance matrix, shrink_estim (default). ... used.","code":""},{"path":"https://danigiro.github.io/FoReco/reference/cscov.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Cross-sectional covariance matrix approximation — cscov","text":"(\\(n \\times n\\)) symmetric positive (semi-)definite matrix.","code":""},{"path":"https://danigiro.github.io/FoReco/reference/cscov.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Cross-sectional covariance matrix approximation — cscov","text":"Di Fonzo, T. Girolimetto, D. (2023), Cross-temporal forecast reconciliation: Optimal combination method heuristic alternatives, International Journal Forecasting, 39, 1, 39-57. doi:10.1016/j.ijforecast.2021.08.004 Wickramasuriya, S.L., Athanasopoulos, G. Hyndman, R.J. (2019), Optimal forecast reconciliation hierarchical grouped time series trace minimization, Journal American Statistical Association, 114, 526, 804-819. doi:10.1080/01621459. 2018.1448825","code":""},{"path":[]},{"path":"https://danigiro.github.io/FoReco/reference/cscov.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Cross-sectional covariance matrix approximation — cscov","text":"","code":"# Aggregation matrix for Z = X + Y A <- t(c(1,1)) # (10 x 3) in-sample residuals matrix (simulated) res <- t(matrix(rnorm(n = 30), nrow = 3))  cov1 <- cscov(\"ols\", n = 3)          # OLS methods cov2 <- cscov(\"str\", agg_mat = A)   # STR methods cov3 <- cscov(\"wls\", res = res)      # WLS methods cov4 <- cscov(\"shr\", res = res)      # SHR methods cov5 <- cscov(\"sam\", res = res)      # SAM methods  # Custom covariance matrix cscov.ols2 <- function(comb, x) diag(x) cscov(comb = \"ols2\", x = 3) # == cscov(\"ols\", n = 3) #>      [,1] [,2] [,3] #> [1,]    1    0    0 #> [2,]    0    1    0 #> [3,]    0    0    1"},{"path":"https://danigiro.github.io/FoReco/reference/cslcc.html","id":null,"dir":"Reference","previous_headings":"","what":"Level conditional coherent reconciliation for genuine hierarchical/grouped time series — cslcc","title":"Level conditional coherent reconciliation for genuine hierarchical/grouped time series — cslcc","text":"function implements cross-sectional forecast reconciliation procedure extends original proposal Hollyman et al. (2021). Level conditional coherent reconciled forecasts conditional (.e., constrained ) base forecasts specific upper level hierarchy (exogenous constraints). also allows handling linear constraints linking variables endogenously (Di Fonzo Girolimetto, 2022). function can calculate Combined Conditional Coherent (CCC) forecasts simple averages Level-Conditional Coherent (LCC) bottom-reconciled forecasts, either endogenous exogenous constraints.","code":""},{"path":"https://danigiro.github.io/FoReco/reference/cslcc.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Level conditional coherent reconciliation for genuine hierarchical/grouped time series — cslcc","text":"","code":"cslcc(base, agg_mat, nodes = \"auto\", comb = \"ols\", res = NULL, CCC = TRUE,       const = \"exogenous\", bts = NULL, approach = \"proj\", nn = NULL,       settings = NULL, ...)"},{"path":"https://danigiro.github.io/FoReco/reference/cslcc.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Level conditional coherent reconciliation for genuine hierarchical/grouped time series — cslcc","text":"base (\\(h \\times n\\)) numeric matrix multivariate time series (mts class) containing base forecasts reconciled; \\(h\\) forecast horizon, \\(n\\) total number time series (\\(n = n_a + n_b\\)). agg_mat (\\(n_a \\times n_b\\)) numeric matrix representing cross-sectional aggregation matrix. maps \\(n_b\\) bottom-level (free) variables \\(n_a\\) upper (constrained) variables. nodes (\\(L \\times 1\\)) numeric vector indicating number variables upper \\(L\\) levels hierarchy. default value string \"auto\" calculates number variables level. comb string specifying reconciliation method. complete list, see cscov. res (\\(N \\times n\\)) optional numeric matrix containing -sample residuals. matrix used compute covariance matrices. CCC logical value indicating whether Combined Conditional Coherent reconciled forecasts reconciliation include bottom-forecasts (TRUE, default), . const string specifying reconciliation constraints: \"exogenous\" (default): Fixes top level sub-hierarchy. \"endogenous\": Coherently revises top bottom levels. bts (\\(h \\times n_b\\)) numeric matrix multivariate time series (mts class) containing bottom base forecasts defined user (e.g., seasonal averages, Hollyman et al., 2021). parameter can omitted base forecasts used (see Di Fonzo Girolimetto, 2024). approach string specifying approach used compute reconciled forecasts. Options include: \"proj\" (default): Projection approach according Byron (1978, 1979). \"strc\": Structural approach proposed Hyndman et al. (2011). \"proj_osqp\": Numerical solution using osqp projection approach. \"strc_osqp\": Numerical solution using osqp structural approach. nn string specifying algorithm compute non-negative reconciled forecasts: \"osqp\": quadratic programming optimization (osqp solver). \"sntz\": heuristic \"set-negative--zero\" (Di Fonzo Girolimetto, 2023). settings object class osqpSettings specifying settings osqp solver. details, refer osqp documentation (Stellato et al., 2020). ... Arguments passed cscov mse TRUE (default) residuals used compute covariance matrix mean-corrected. shrink_fun Shrinkage function covariance matrix, shrink_estim (default).","code":""},{"path":"https://danigiro.github.io/FoReco/reference/cslcc.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Level conditional coherent reconciliation for genuine hierarchical/grouped time series — cslcc","text":"(\\(h \\times n\\)) numeric matrix cross-sectional reconciled forecasts.","code":""},{"path":"https://danigiro.github.io/FoReco/reference/cslcc.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Level conditional coherent reconciliation for genuine hierarchical/grouped time series — cslcc","text":"Byron, R.P. (1978), estimation large social account matrices, Journal Royal Statistical Society, Series , 141, 3, 359-367. doi:10.2307/2344807 Byron, R.P. (1979), Corrigenda: estimation large social account matrices, Journal Royal Statistical Society, Series , 142(3), 405. doi:10.2307/2982515 Di Fonzo, T. Girolimetto, D. (2024), Forecast combination-based forecast reconciliation: Insights extensions, International Journal Forecasting, 40(2), 490–514. doi:10.1016/j.ijforecast.2022.07.001 Di Fonzo, T. Girolimetto, D. (2023b) Spatio-temporal reconciliation solar forecasts. Solar Energy 251, 13–29. doi:10.1016/j.solener.2023.01.003 Hyndman, R.J., Ahmed, R.., Athanasopoulos, G. Shang, H.L. (2011), Optimal combination forecasts hierarchical time series, Computational Statistics & Data Analysis, 55, 9, 2579-2589. doi:10.1016/j.csda.2011.03.006 Hollyman, R., Petropoulos, F. Tipping, M.E. (2021), Understanding forecast reconciliation. European Journal Operational Research, 294, 149–160. doi:10.1016/j.ejor.2021.01.017 Stellato, B., Banjac, G., Goulart, P., Bemporad, . Boyd, S. (2020), OSQP: Operator Splitting solver Quadratic Programs, Mathematical Programming Computation, 12, 4, 637-672. doi:10.1007/s12532-020-00179-2","code":""},{"path":[]},{"path":"https://danigiro.github.io/FoReco/reference/cslcc.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Level conditional coherent reconciliation for genuine hierarchical/grouped time series — cslcc","text":"","code":"set.seed(123) # Aggregation matrix for Z = X + Y, X = XX + XY and Y = YX + YY A <- matrix(c(1,1,1,1,1,1,0,0,0,0,1,1), 3, byrow = TRUE) # (2 x 7) base forecasts matrix (simulated) base <- matrix(rnorm(7*2, mean = c(40, 20, 20, 10, 10, 10, 10)), 2, byrow = TRUE) # (10 x 7) in-sample residuals matrix (simulated) res <- matrix(rnorm(n = 7*10), ncol = 7) # (2 x 7) Naive bottom base forecasts matrix: all forecasts are set equal to 10 naive <- matrix(10, 2, 4)  ## EXOGENOUS CONSTRAINTS (Hollyman et al., 2021) # Level Conditional Coherent (LCC) reconciled forecasts exo_LC <- cslcc(base = base, agg_mat = A, comb = \"wls\", bts = naive,                 res = res, nodes = \"auto\", CCC = FALSE)  # Combined Conditional Coherent (CCC) reconciled forecasts exo_CCC <- cslcc(base = base, agg_mat = A, comb = \"wls\", bts = naive,                  res = res, nodes = \"auto\", CCC = TRUE)  # Results detailed by level: # L-1: Level 1 immutable reconciled forecasts for the whole hierarchy # L-2: Middle-Out reconciled forecasts # L-3: Bottom-Up reconciled forecasts info_exo <- recoinfo(exo_CCC, verbose = FALSE) info_exo$lcc #> $`L-1` #>          s-1      s-2      s-3      s-4      s-5      s-6      s-7 #> h-1 39.43952 19.76757 19.67196 9.893588 9.873979 9.744387 9.927570 #> h-2 38.73494 19.47537 19.25957 9.759815 9.715556 9.423051 9.836517 #> attr(,\"FoReco\") #> <environment: 0x11371d2d0> #>  #> $`L-2` #>          s-1      s-2      s-3      s-4      s-5       s-6       s-7 #> h-1 41.32853 19.76982 21.55871 9.894620 9.875202 11.214555 10.344153 #> h-2 38.86749 19.31315 19.55434 9.685546 9.627601  9.652737  9.901601 #> attr(,\"FoReco\") #> <environment: 0x1134369a0> #>  #> $`L-3` #>          s-1     s-2      s-3      s-4      s-5      s-6      s-7 #> h-1 42.37578 20.1998 22.17598 10.07051 10.12929 11.71506 10.46092 #> h-2 42.09535 21.5839 20.51145 11.22408 10.35981 10.40077 10.11068 #> attr(,\"FoReco\") #> <environment: 0x1133a4fb8> #>   ## ENDOGENOUS CONSTRAINTS (Di Fonzo and Girolimetto, 2024) # Level Conditional Coherent (LCC) reconciled forecasts endo_LC <- cslcc(base = base, agg_mat = A, comb = \"wls\",                  res = res, nodes = \"auto\", CCC = FALSE,                  const = \"endogenous\")  # Combined Conditional Coherent (CCC) reconciled forecasts endo_CCC <- cslcc(base = base, agg_mat = A, comb = \"wls\",                   res = res, nodes = \"auto\", CCC = TRUE,                   const = \"endogenous\")  # Results detailed by level: # L-1: Level 1 reconciled forecasts for L1 + L3 (bottom level) # L-2: Level 2 reconciled forecasts for L2 + L3 (bottom level) # L-3: Bottom-Up reconciled forecasts info_endo <- recoinfo(endo_CCC, verbose = FALSE) info_endo$lcc #> $`L-1` #>          s-1      s-2      s-3       s-4      s-5       s-6       s-7 #> h-1 40.23685 19.31277 20.92408  9.664411 9.648359 10.739579 10.184505 #> h-2 39.64745 20.56873 19.07871 10.759321 9.809413  9.284371  9.794343 #> attr(,\"FoReco\") #> <environment: 0x110a63bc0> #>  #> $`L-2` #>          s-1      s-2      s-3       s-4      s-5       s-6       s-7 #> h-1 41.70862 19.94714 21.76149  9.954836 9.992300 11.392087 10.369398 #> h-2 40.11832 20.24956 19.86876 10.613199 9.636364  9.899977  9.968779 #> attr(,\"FoReco\") #> <environment: 0x126456b70> #>  #> $`L-3` #>          s-1     s-2      s-3      s-4      s-5      s-6      s-7 #> h-1 42.37578 20.1998 22.17598 10.07051 10.12929 11.71506 10.46092 #> h-2 42.09535 21.5839 20.51145 11.22408 10.35981 10.40077 10.11068 #> attr(,\"FoReco\") #> <environment: 0x126127ee8> #>"},{"path":"https://danigiro.github.io/FoReco/reference/csmo.html","id":null,"dir":"Reference","previous_headings":"","what":"Cross-sectional middle-out reconciliation — csmo","title":"Cross-sectional middle-out reconciliation — csmo","text":"middle-forecast reconciliation (Athanasopoulos et al., 2009) combines top-(cstd) bottom-(csbu) genuine hierarchical/grouped time series. Given base forecasts variables intermediate level \\(l\\), performs top-approach levels \\(<l\\); bottom-approach levels \\(>l\\).","code":""},{"path":"https://danigiro.github.io/FoReco/reference/csmo.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Cross-sectional middle-out reconciliation — csmo","text":"","code":"csmo(base, agg_mat, id_rows = 1, weights, normalize = TRUE)"},{"path":"https://danigiro.github.io/FoReco/reference/csmo.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Cross-sectional middle-out reconciliation — csmo","text":"base (\\(h \\times n_l\\)) numeric matrix containing \\(l\\)-level base forecast; \\(n_l\\) number variables level \\(l\\), \\(h\\) forecast horizon. agg_mat (\\(n_a \\times n_b\\)) numeric matrix representing cross-sectional aggregation matrix. maps \\(n_b\\) bottom-level (free) variables \\(n_a\\) upper (constrained) variables. id_rows numeric vector indicating \\(l\\)-level rows agg_mat. weights (\\(h \\times n_b\\)) numeric matrix containing proportions bottom time series; \\(h\\) forecast horizon, \\(n_b\\) total number bottom variables. normalize TRUE (default), weights sum 1.","code":""},{"path":"https://danigiro.github.io/FoReco/reference/csmo.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Cross-sectional middle-out reconciliation — csmo","text":"(\\(h \\times n\\)) numeric matrix cross-sectional reconciled forecasts.","code":""},{"path":"https://danigiro.github.io/FoReco/reference/csmo.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Cross-sectional middle-out reconciliation — csmo","text":"Athanasopoulos, G., Ahmed, R. . Hyndman, R.J. (2009) Hierarchical forecasts Australian domestic tourism. International Journal Forecasting 25(1), 146–166. doi:10.1016/j.ijforecast.2008.07.004","code":""},{"path":[]},{"path":"https://danigiro.github.io/FoReco/reference/csmo.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Cross-sectional middle-out reconciliation — csmo","text":"","code":"set.seed(123) # Aggregation matrix for Z = X + Y, X = XX + XY and Y = YX + YY A <- matrix(c(1,1,1,1,1,1,0,0,0,0,1,1), 3, byrow = TRUE) # (3 x 2) top base forecasts vector (simulated), forecast horizon = 3 baseL2 <- matrix(rnorm(2*3, 5), 3, 2) # Same weights for different forecast horizons fix_weights <- runif(4) reco <- csmo(base = baseL2, agg_mat = A, id_rows = 2:3, weights = fix_weights)  # Different weights for different forecast horizons h_weights <- matrix(runif(4*3), 3, 4) recoh <- csmo(base = baseL2, agg_mat = A, id_rows = 2:3, weights = h_weights)"},{"path":"https://danigiro.github.io/FoReco/reference/csprojmat.html","id":null,"dir":"Reference","previous_headings":"","what":"Projection matrix for optimal combination cross-sectional reconciliation — csprojmat","title":"Projection matrix for optimal combination cross-sectional reconciliation — csprojmat","text":"function computes projection mapping matrix \\(\\mathbf{M}\\) \\(\\mathbf{G}\\), respectively, \\(\\widetilde{\\mathbf{y}} = \\mathbf{M}\\widehat{\\mathbf{y}} = \\mathbf{S}_{cs}\\mathbf{G}\\widehat{\\mathbf{y}}\\), \\(\\widetilde{\\mathbf{y}}\\) vector reconciled forecasts, \\(\\widehat{\\mathbf{y}}\\) vector base forecasts, \\(\\mathbf{S}_{cs}\\) cross-sectional structural matrix, \\(\\mathbf{M} = \\mathbf{S}_{cs}\\mathbf{G}\\). information regarding structure matrices, refer Girolimetto et al. (2023).","code":""},{"path":"https://danigiro.github.io/FoReco/reference/csprojmat.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Projection matrix for optimal combination cross-sectional reconciliation — csprojmat","text":"","code":"csprojmat(agg_mat, cons_mat, comb = \"ols\", res = NULL, mat = \"M\", ...)"},{"path":"https://danigiro.github.io/FoReco/reference/csprojmat.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Projection matrix for optimal combination cross-sectional reconciliation — csprojmat","text":"agg_mat (\\(n_a \\times n_b\\)) numeric matrix representing cross-sectional aggregation matrix. maps \\(n_b\\) bottom-level (free) variables \\(n_a\\) upper (constrained) variables. cons_mat (\\(n_a \\times n\\)) numeric matrix representing cross-sectional zero constraints. spans null space reconciled forecasts. comb string specifying reconciliation method. complete list, see cscov. res (\\(N \\times n\\)) optional numeric matrix containing -sample residuals. matrix used compute covariance matrices. mat string specifying matrix return: \"M\" (default) \\(\\mathbf{M}\\) \"G\" \\(\\mathbf{G}\\). ... Arguments passed cscov mse TRUE (default) residuals used compute covariance matrix mean-corrected. shrink_fun Shrinkage function covariance matrix, shrink_estim (default).","code":""},{"path":"https://danigiro.github.io/FoReco/reference/csprojmat.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Projection matrix for optimal combination cross-sectional reconciliation — csprojmat","text":"projection matrix \\(\\mathbf{M}\\) (mat = \"M\") mapping matrix \\(\\mathbf{G}\\) (mat = \"G\").","code":""},{"path":"https://danigiro.github.io/FoReco/reference/csprojmat.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Projection matrix for optimal combination cross-sectional reconciliation — csprojmat","text":"Girolimetto, D., Athanasopoulos, G., Di Fonzo, T. Hyndman, R.J. (2024), Cross-temporal probabilistic forecast reconciliation: Methodological practical issues. International Journal Forecasting, 40, 3, 1134-1151. doi:10.1016/j.ijforecast.2023. 10.003","code":""},{"path":[]},{"path":"https://danigiro.github.io/FoReco/reference/csprojmat.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Projection matrix for optimal combination cross-sectional reconciliation — csprojmat","text":"","code":"# Cross-sectional framework A <- t(c(1,1)) # Aggregation matrix for Z = X + Y Mcs <- csprojmat(agg_mat = A, comb = \"ols\") Gcs <- csprojmat(agg_mat = A, comb = \"ols\", mat = \"G\")"},{"path":"https://danigiro.github.io/FoReco/reference/csrec.html","id":null,"dir":"Reference","previous_headings":"","what":"Optimal combination cross-sectional reconciliation — csrec","title":"Optimal combination cross-sectional reconciliation — csrec","text":"function performs optimal (least squares sense) combination cross-sectional forecast reconciliation linearly constrained (e.g., hierarchical/grouped) multiple time series (Wickramasuriya et al., 2019, Panagiotelis et al., 2022, Girolimetto Di Fonzo, 2023). reconciled forecasts calculated using either projection approach (Byron, 1978, 1979) equivalent structural approach Hyndman et al. (2011). Non-negative (Di Fonzo Girolimetto, 2023) immutable (including Zhang et al., 2023) reconciled forecasts can considered.","code":""},{"path":"https://danigiro.github.io/FoReco/reference/csrec.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Optimal combination cross-sectional reconciliation — csrec","text":"","code":"csrec(base, agg_mat, cons_mat, comb = \"ols\", res = NULL, approach = \"proj\",       nn = NULL, settings = NULL, bounds = NULL, immutable = NULL, ...)"},{"path":"https://danigiro.github.io/FoReco/reference/csrec.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Optimal combination cross-sectional reconciliation — csrec","text":"base (\\(h \\times n\\)) numeric matrix multivariate time series (mts class) containing base forecasts reconciled; \\(h\\) forecast horizon, \\(n\\) total number time series (\\(n = n_a + n_b\\)). agg_mat (\\(n_a \\times n_b\\)) numeric matrix representing cross-sectional aggregation matrix. maps \\(n_b\\) bottom-level (free) variables \\(n_a\\) upper (constrained) variables. cons_mat (\\(n_a \\times n\\)) numeric matrix representing cross-sectional zero constraints. spans null space reconciled forecasts. comb string specifying reconciliation method. complete list, see cscov. res (\\(N \\times n\\)) optional numeric matrix containing -sample residuals. matrix used compute covariance matrices. approach string specifying approach used compute reconciled forecasts. Options include: \"proj\" (default): Projection approach according Byron (1978, 1979). \"strc\": Structural approach proposed Hyndman et al. (2011). \"proj_osqp\": Numerical solution using osqp projection approach. \"strc_osqp\": Numerical solution using osqp structural approach. nn string specifying algorithm compute non-negative reconciled forecasts: \"osqp\": quadratic programming optimization (osqp solver). \"sntz\": heuristic \"set-negative--zero\" (Di Fonzo Girolimetto, 2023). settings object class osqpSettings specifying settings osqp solver. details, refer osqp documentation (Stellato et al., 2020). bounds (\\(n \\times 2\\)) numeric matrix specifying cross-sectional bounds. first column represents lower bound, second column represents upper bound. immutable numeric vector containing column indices base forecasts (base parameter) fixed. ... Arguments passed cscov mse TRUE (default) residuals used compute covariance matrix mean-corrected. shrink_fun Shrinkage function covariance matrix, shrink_estim (default).","code":""},{"path":"https://danigiro.github.io/FoReco/reference/csrec.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Optimal combination cross-sectional reconciliation — csrec","text":"(\\(h \\times n\\)) numeric matrix cross-sectional reconciled forecasts.","code":""},{"path":"https://danigiro.github.io/FoReco/reference/csrec.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Optimal combination cross-sectional reconciliation — csrec","text":"Byron, R.P. (1978), estimation large social account matrices, Journal Royal Statistical Society, Series , 141, 3, 359-367. doi:10.2307/2344807 Byron, R.P. (1979), Corrigenda: estimation large social account matrices, Journal Royal Statistical Society, Series , 142(3), 405. doi:10.2307/2982515 Di Fonzo, T. Girolimetto, D. (2023), Spatio-temporal reconciliation solar forecasts, Solar Energy, 251, 13–29. doi:10.1016/j.solener.2023.01.003 Girolimetto, D. Di Fonzo, T. (2023), Point probabilistic forecast reconciliation general linearly constrained multiple time series, Statistical Methods & Applications, press. doi:10.1007/s10260-023-00738-6 . Hyndman, R.J., Ahmed, R.., Athanasopoulos, G. Shang, H.L. (2011), Optimal combination forecasts hierarchical time series, Computational Statistics & Data Analysis, 55, 9, 2579-2589. doi:10.1016/j.csda.2011.03.006 Panagiotelis, ., Athanasopoulos, G., Gamakumara, P. Hyndman, R.J. (2021), Forecast reconciliation: geometric view new insights bias correction, International Journal Forecasting, 37, 1, 343–359. doi:10.1016/j.ijforecast.2020.06.004 Stellato, B., Banjac, G., Goulart, P., Bemporad, . Boyd, S. (2020), OSQP: Operator Splitting solver Quadratic Programs, Mathematical Programming Computation, 12, 4, 637-672. doi:10.1007/s12532-020-00179-2 Wickramasuriya, S.L., Athanasopoulos, G. Hyndman, R.J. (2019), Optimal forecast reconciliation hierarchical grouped time series trace minimization, Journal American Statistical Association, 114, 526, 804-819. doi:10.1080/ 01621459.2018.1448825 Zhang, B., Kang, Y., Panagiotelis, . Li, F. (2023), Optimal reconciliation immutable forecasts, European Journal Operational Research, 308(2), 650–660. doi:10.1016/j.ejor.2022.11.035","code":""},{"path":[]},{"path":"https://danigiro.github.io/FoReco/reference/csrec.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Optimal combination cross-sectional reconciliation — csrec","text":"","code":"set.seed(123) # (2 x 3) base forecasts matrix (simulated), Z = X + Y base <- matrix(rnorm(6, mean = c(20, 10, 10)), 2, byrow = TRUE) # (10 x 3) in-sample residuals matrix (simulated) res <- t(matrix(rnorm(n = 30), nrow = 3))  # Aggregation matrix for Z = X + Y A <- t(c(1,1)) reco <- csrec(base = base, agg_mat = A, comb = \"wls\", res = res)  # Zero constraints matrix for Z - X - Y = 0 C <- t(c(1, -1, -1)) reco <- csrec(base = base, cons_mat = C, comb = \"wls\", res = res) # same results  # Non negative reconciliation base[1,3] <- -base[1,3] # Making negative one of the base forecasts for variable Y nnreco <- csrec(base = base, agg_mat = A, comb = \"wls\", res = res, nn = \"osqp\") recoinfo(nnreco, verbose = FALSE)$info #>     obj_val   run_time iter    pri_res status status_polish #> 1 -352.4619 2.5541e-05   25 1.7763e-15      1             1"},{"path":"https://danigiro.github.io/FoReco/reference/cstd.html","id":null,"dir":"Reference","previous_headings":"","what":"Cross-sectional top-down reconciliation — cstd","title":"Cross-sectional top-down reconciliation — cstd","text":"Top-forecast reconciliation genuine hierarchical/grouped time series (Gross Sohl, 1990), forecast `Total' (top-level series, expected positive) disaggregated according proportional scheme (weights). Besides fulfilling aggregation constraint, top-reconciled forecasts respect two main properties: top-level value remains unchanged; bottom time series reconciled forecasts non-negative.","code":""},{"path":"https://danigiro.github.io/FoReco/reference/cstd.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Cross-sectional top-down reconciliation — cstd","text":"","code":"cstd(base, agg_mat, weights, normalize = TRUE)"},{"path":"https://danigiro.github.io/FoReco/reference/cstd.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Cross-sectional top-down reconciliation — cstd","text":"base (\\(h \\times 1\\)) numeric vector containing top-level base forecast; \\(h\\) forecast horizon. agg_mat (\\(n_a \\times n_b\\)) numeric matrix representing cross-sectional aggregation matrix. maps \\(n_b\\) bottom-level (free) variables \\(n_a\\) upper (constrained) variables. weights (\\(h \\times n_b\\)) numeric matrix containing proportions bottom time series; \\(h\\) forecast horizon, \\(n_b\\) total number bottom variables. normalize TRUE (default), weights sum 1.","code":""},{"path":"https://danigiro.github.io/FoReco/reference/cstd.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Cross-sectional top-down reconciliation — cstd","text":"(\\(h \\times n\\)) numeric matrix cross-sectional reconciled forecasts.","code":""},{"path":"https://danigiro.github.io/FoReco/reference/cstd.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Cross-sectional top-down reconciliation — cstd","text":"Gross, C.W. Sohl, J.E. (1990), Disaggregation methods expedite product line forecasting. Journal Forecasting 9(3), 233–254. doi:10.1002/.3980090304","code":""},{"path":[]},{"path":"https://danigiro.github.io/FoReco/reference/cstd.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Cross-sectional top-down reconciliation — cstd","text":"","code":"set.seed(123) # Aggregation matrix for Z = X + Y, X = XX + XY and Y = YX + YY A <- matrix(c(1,1,1,1,1,1,0,0,0,0,1,1), 3, byrow = TRUE) # (3 x 1) top base forecasts vector (simulated), forecast horizon = 3 topf <- rnorm(3, 10) # Same weights for different forecast horizons fix_weights <- runif(4) reco <- cstd(base = topf, agg_mat = A, weights = fix_weights)  # Different weights for different forecast horizons h_weights <- matrix(runif(4*3), 3, 4) recoh <- cstd(base = topf, agg_mat = A, weights = h_weights)"},{"path":"https://danigiro.github.io/FoReco/reference/cstools.html","id":null,"dir":"Reference","previous_headings":"","what":"Cross-sectional reconciliation tools — cstools","title":"Cross-sectional reconciliation tools — cstools","text":"useful tools cross-sectional forecast reconciliation linearly constrained (e.g., hierarchical/grouped) multiple time series.","code":""},{"path":"https://danigiro.github.io/FoReco/reference/cstools.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Cross-sectional reconciliation tools — cstools","text":"","code":"cstools(agg_mat, cons_mat, sparse = TRUE)"},{"path":"https://danigiro.github.io/FoReco/reference/cstools.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Cross-sectional reconciliation tools — cstools","text":"agg_mat (\\(n_a \\times n_b\\)) numeric matrix representing cross-sectional aggregation matrix. maps \\(n_b\\) bottom-level (free) variables \\(n_a\\) upper (constrained) variables. cons_mat (\\(n_a \\times n\\)) numeric matrix representing cross-sectional zero constraints. spans null space reconciled forecasts. sparse Option return sparse matrices (default TRUE).","code":""},{"path":"https://danigiro.github.io/FoReco/reference/cstools.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Cross-sectional reconciliation tools — cstools","text":"list four elements: dim vector containing information number series complete system (n), upper levels (na) bottom level (nb). agg_mat cross-sectional aggregation matrix. strc_mat cross-sectional structural matrix. cons_mat cross-sectional zero constraints matrix.","code":""},{"path":[]},{"path":"https://danigiro.github.io/FoReco/reference/cstools.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Cross-sectional reconciliation tools — cstools","text":"","code":"# Cross-sectional framework # One level hierarchy A = [1 1] A <- matrix(1, 1, 2) obj <- cstools(agg_mat = A)"},{"path":"https://danigiro.github.io/FoReco/reference/ctboot.html","id":null,"dir":"Reference","previous_headings":"","what":"Cross-temporal joint block bootstrap — ctboot","title":"Cross-temporal joint block bootstrap — ctboot","text":"Joint block bootstrap generating probabilistic base forecasts take account correlation variables different temporal aggregation orders (Girolimetto et al. 2023).","code":""},{"path":"https://danigiro.github.io/FoReco/reference/ctboot.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Cross-temporal joint block bootstrap — ctboot","text":"","code":"ctboot(model_list, boot_size, agg_order, block_size = 1, seed = NULL)"},{"path":"https://danigiro.github.io/FoReco/reference/ctboot.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Cross-temporal joint block bootstrap — ctboot","text":"model_list list \\(n\\) elements, one cross-sectional series. elements list \\((k^\\ast+m)\\) base forecasts models ordered lowest frequency (temporally aggregated) highest frequency. simulate() function model available implemented according package forecast, following mandatory parameters: object, innov, future, nsim. boot_size number bootstrap replicates. agg_order Highest available sampling frequency per seasonal cycle (max. order temporal aggregation, \\(m\\)), vector representing subset \\(p\\) factors \\(m\\). block_size Block size bootstrap, typically equivalent forecast horizon temporally aggregated series. seed integer seed.","code":""},{"path":"https://danigiro.github.io/FoReco/reference/ctboot.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Cross-temporal joint block bootstrap — ctboot","text":"list two elements: seed used sample errors (\\(\\text{boot\\_size}\\times n(k^\\ast+m)\\text{block\\_size}\\)) matrix.","code":""},{"path":"https://danigiro.github.io/FoReco/reference/ctboot.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Cross-temporal joint block bootstrap — ctboot","text":"Girolimetto, D., Athanasopoulos, G., Di Fonzo, T. Hyndman, R.J. (2023), Cross-temporal probabilistic forecast reconciliation: Methodological practical issues. International Journal Forecasting, press. doi:10.1016/j.ijforecast.2023. 10.003","code":""},{"path":[]},{"path":"https://danigiro.github.io/FoReco/reference/ctbu.html","id":null,"dir":"Reference","previous_headings":"","what":"Cross-temporal bottom-up reconciliation — ctbu","title":"Cross-temporal bottom-up reconciliation — ctbu","text":"Cross-temporal bottom-reconciled forecasts series temporal aggregation level computed appropriate summation high-frequency bottom base forecasts \\(\\widehat{\\mathbf{B}^{[1]}}\\): $$\\widetilde{\\mathbf{X}} = \\mathbf{S}_{cs}\\widehat{\\mathbf{B}^{[1]}}\\mathbf{S}'_{te},$$ \\(\\mathbf{S}_{cs}\\) \\(\\mathbf{S}_{te}\\) cross-sectional temporal structural matrices, respectively.","code":""},{"path":"https://danigiro.github.io/FoReco/reference/ctbu.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Cross-temporal bottom-up reconciliation — ctbu","text":"","code":"ctbu(base, agg_mat, agg_order, tew = \"sum\", sntz = FALSE)"},{"path":"https://danigiro.github.io/FoReco/reference/ctbu.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Cross-temporal bottom-up reconciliation — ctbu","text":"base (\\(n_b \\times hm\\)) numeric matrix containing high-frequency bottom base forecasts; \\(n_b\\) total number high-frequency bottom variables, \\(m\\) max aggregation order, \\(h\\) forecast horizon lowest frequency time series. agg_mat (\\(n_a \\times n_b\\)) numeric matrix representing cross-sectional aggregation matrix. maps \\(n_b\\) bottom-level (free) variables \\(n_a\\) upper (constrained) variables. agg_order Highest available sampling frequency per seasonal cycle (max. order temporal aggregation, \\(m\\)), vector representing subset \\(p\\) factors \\(m\\). tew string specifying type temporal aggregation. Options include: \"sum\" (simple summation, default), \"avg\" (average), \"first\" (first value period), \"last\" (last value period). sntz TRUE, negative base forecasts set zero applying bottom-.","code":""},{"path":"https://danigiro.github.io/FoReco/reference/ctbu.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Cross-temporal bottom-up reconciliation — ctbu","text":"(\\(n \\times h(k^\\ast+m)\\)) numeric matrix cross-temporal reconciled forecasts.","code":""},{"path":[]},{"path":"https://danigiro.github.io/FoReco/reference/ctbu.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Cross-temporal bottom-up reconciliation — ctbu","text":"","code":"set.seed(123) # Aggregation matrix for Z = X + Y A <- t(c(1,1)) # (2 x 4) high frequency bottom base forecasts matrix (simulated), # agg_order = 4 (annual-quarterly) hfbts <- matrix(rnorm(4*2, 2.5), 2, 4)  reco <- ctbu(base = hfbts, agg_mat = A, agg_order = 4)  # Non negative reconciliation hfbts[1,4] <- -hfbts[1,4] # Making negative one of the quarterly base forecasts for variable X nnreco <- ctbu(base = hfbts, agg_mat = A, agg_order = 4, sntz = TRUE)"},{"path":"https://danigiro.github.io/FoReco/reference/ctcov.html","id":null,"dir":"Reference","previous_headings":"","what":"Cross-temporal covariance matrix approximation — ctcov","title":"Cross-temporal covariance matrix approximation — ctcov","text":"function provides approximation cross-temporal base forecasts errors covariance matrix using different reconciliation methods (Di Fonzo Girolimetto, 2023, Girolimetto et al., 2023).","code":""},{"path":"https://danigiro.github.io/FoReco/reference/ctcov.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Cross-temporal covariance matrix approximation — ctcov","text":"","code":"ctcov(comb = \"ols\", n = NULL, agg_mat = NULL, agg_order = NULL, res = NULL,       tew = \"sum\", mse = TRUE, shrink_fun = shrink_estim, ...)"},{"path":"https://danigiro.github.io/FoReco/reference/ctcov.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Cross-temporal covariance matrix approximation — ctcov","text":"comb string specifying reconciliation method. Ordinary least squares: \"ols\" (default) - identity error covariance. Weighted least squares: \"str\" - structural variances. \"csstr\" - cross-sectional structural variances. \"testr\" - temporal structural variances. \"wlsh\" - hierarchy variances (uses res). \"wlsv\" - series variances (uses res). Generalized least squares (uses res): \"acov\" - series auto-covariance. \"bdshr\"/\"bdsam\" - shrunk/sample block diagonal cross-sectional covariance. \"Sshr\"/\"Ssam\" - series shrunk/sample covariance. \"shr\"/\"sam\" - shrunk/sample covariance. \"hbshr\"/\"hbsam\" - shrunk/sample high frequency bottom time series covariance. \"bshr\"/\"bsam\" - shrunk/sample bottom time series covariance. \"hshr\"/\"hsam\" - shrunk/sample high frequency covariance. n Cross-sectional number variables. agg_mat (\\(n_a \\times n_b\\)) numeric matrix representing cross-sectional aggregation matrix. maps \\(n_b\\) bottom-level (free) variables \\(n_a\\) upper (constrained) variables. agg_order Highest available sampling frequency per seasonal cycle (max. order temporal aggregation, \\(m\\)), vector representing subset \\(p\\) factors \\(m\\). res (\\(n \\times N(k^\\ast+m)\\)) optional numeric matrix containing -sample residuals temporal frequencies ordered lowest frequency highest frequency (columns) variable (rows). matrix used compute covariance matrices. tew string specifying type temporal aggregation. Options include: \"sum\" (simple summation, default), \"avg\" (average), \"first\" (first value period), \"last\" (last value period). mse TRUE (default) residuals used compute covariance matrix mean-corrected. shrink_fun Shrinkage function covariance matrix, shrink_estim (default). ... used.","code":""},{"path":"https://danigiro.github.io/FoReco/reference/ctcov.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Cross-temporal covariance matrix approximation — ctcov","text":"(\\(n(k^\\ast+m) \\times n(k^\\ast+m)\\)) symmetric matrix.","code":""},{"path":"https://danigiro.github.io/FoReco/reference/ctcov.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Cross-temporal covariance matrix approximation — ctcov","text":"Di Fonzo, T. Girolimetto, D. (2023), Cross-temporal forecast reconciliation: Optimal combination method heuristic alternatives, International Journal Forecasting, 39, 1, 39-57. doi:10.1016/j.ijforecast.2021.08.004 Girolimetto, D., Athanasopoulos, G., Di Fonzo, T. Hyndman, R.J. (2024), Cross-temporal probabilistic forecast reconciliation: Methodological practical issues. International Journal Forecasting, 40, 3, 1134-1151. doi:10.1016/j.ijforecast.2023. 10.003","code":""},{"path":[]},{"path":"https://danigiro.github.io/FoReco/reference/ctcov.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Cross-temporal covariance matrix approximation — ctcov","text":"","code":"set.seed(123) # Aggregation matrix for Z = X + Y A <- t(c(1,1)) # (3 x 70) in-sample residuals matrix (simulated), # agg_order = 4 (annual-quarterly) res <- rbind(rnorm(70), rnorm(70), rnorm(70))  cov1 <- ctcov(\"ols\", n = 3, agg_order = 4)                     # OLS methods cov2 <- ctcov(\"str\", agg_mat = A, agg_order = 4)               # STR methods cov3 <- ctcov(\"csstr\", agg_mat = A, agg_order = 4)             # CSSTR methods cov4 <- ctcov(\"testr\", n = 3, agg_order = 4)                   # TESTR methods cov5 <- ctcov(\"wlsv\", agg_order = 4, res = res)                # WLSv methods cov6 <- ctcov(\"wlsh\", agg_order = 4, res = res)                # WLSh methods cov7 <- ctcov(\"shr\", agg_order = 4, res = res)                 # SHR methods cov8 <- ctcov(\"sam\", agg_order = 4, res = res)                 # SAM methods cov9 <- ctcov(\"acov\", agg_order = 4, res = res)                # ACOV methods cov10 <- ctcov(\"Sshr\", agg_order = 4, res = res)               # Sshr methods cov11 <- ctcov(\"Ssam\", agg_order = 4, res = res)               # Ssam methods cov12 <- ctcov(\"hshr\", agg_order = 4, res = res)               # Hshr methods cov13 <- ctcov(\"hsam\", agg_order = 4, res = res)               # Hsam methods cov14 <- ctcov(\"hbshr\", agg_mat = A, agg_order = 4, res = res) # HBshr methods #> [1] 0.5736559 cov15 <- ctcov(\"hbsam\", agg_mat = A, agg_order = 4, res = res) # HBsam methods cov16 <- ctcov(\"bshr\", agg_mat = A, agg_order = 4, res = res)  # Bshr methods cov17 <- ctcov(\"bsam\", agg_mat = A, agg_order = 4, res = res)  # Bsam methods cov18 <- ctcov(\"bdshr\", agg_order = 4, res = res)              # BDshr methods cov19 <- ctcov(\"bdsam\", agg_order = 4, res = res)              # BDsam methods  # Custom covariance matrix ctcov.ols2 <- function(comb, x) diag(x) cov20 <- ctcov(comb = \"ols2\", x = 21) # == ctcov(\"ols\", n = 3, agg_order = 4)"},{"path":"https://danigiro.github.io/FoReco/reference/ctlcc.html","id":null,"dir":"Reference","previous_headings":"","what":"Level conditional coherent reconciliation for cross-temporal hierarchies — ctlcc","title":"Level conditional coherent reconciliation for cross-temporal hierarchies — ctlcc","text":"function implements forecast reconciliation procedure inspired original proposal Hollyman et al. (2021) cross-temporal hierarchies. Level conditional coherent reconciled forecasts conditional (.e., constrained ) base forecasts specific upper level hierarchy (exogenous constraints). also allows handling linear constraints linking variables endogenously (Di Fonzo Girolimetto, 2022). function can calculate Combined Conditional Coherent (CCC) forecasts simple averages Level-Conditional Coherent (LCC) bottom-reconciled forecasts, either endogenous exogenous constraints.","code":""},{"path":"https://danigiro.github.io/FoReco/reference/ctlcc.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Level conditional coherent reconciliation for cross-temporal hierarchies — ctlcc","text":"","code":"ctlcc(base, agg_mat, nodes = \"auto\", agg_order, comb = \"ols\", res = NULL,       CCC = TRUE, const = \"exogenous\", hfbts = NULL, tew = \"sum\",       approach = \"proj\", nn = NULL, settings = NULL, ...)"},{"path":"https://danigiro.github.io/FoReco/reference/ctlcc.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Level conditional coherent reconciliation for cross-temporal hierarchies — ctlcc","text":"base (\\(n \\times h(k^\\ast+m)\\)) numeric matrix containing base forecasts reconciled; \\(n\\) total number variables, \\(m\\) max. order temporal aggregation, \\(k^\\ast\\) sum (subset ) (\\(p-1\\)) factors \\(m\\), excluding \\(m\\), \\(h\\) forecast horizon lowest frequency time series. row identifies time series, forecasts row ordered lowest frequency (temporally aggregated) highest frequency. agg_mat (\\(n_a \\times n_b\\)) numeric matrix representing cross-sectional aggregation matrix. maps \\(n_b\\) bottom-level (free) variables \\(n_a\\) upper (constrained) variables. nodes (\\(L \\times 1\\)) numeric vector indicating number variables upper \\(L\\) levels hierarchy. default value string \"auto\" calculates number variables level. agg_order Highest available sampling frequency per seasonal cycle (max. order temporal aggregation, \\(m\\)), vector representing subset \\(p\\) factors \\(m\\). comb string specifying reconciliation method. complete list, see ctcov. res (\\(n \\times N(k^\\ast+m)\\)) optional numeric matrix containing -sample residuals temporal frequencies ordered lowest frequency highest frequency (columns) variable (rows). matrix used compute covariance matrices. CCC logical value indicating whether Combined Conditional Coherent reconciled forecasts reconciliation include bottom-forecasts (TRUE, default), . const string specifying reconciliation constraints: \"exogenous\" (default): Fixes top level sub-hierarchy. \"endogenous\": Coherently revises top bottom levels. hfbts (\\(n \\times mh\\)) numeric matrix containing high frequency bottom base forecasts defined user. parameter can omitted base forecasts used (see Di Fonzo Girolimetto, 2024). tew string specifying type temporal aggregation. Options include: \"sum\" (simple summation, default), \"avg\" (average), \"first\" (first value period), \"last\" (last value period). approach string specifying approach used compute reconciled forecasts. Options include: \"proj\" (default): Projection approach according Byron (1978, 1979). \"strc\": Structural approach proposed Hyndman et al. (2011). \"proj_osqp\": Numerical solution using osqp projection approach. \"strc_osqp\": Numerical solution using osqp structural approach. nn string specifying algorithm compute non-negative reconciled forecasts: \"osqp\": quadratic programming optimization (osqp solver). \"sntz\": heuristic \"set-negative--zero\" (Di Fonzo Girolimetto, 2023). settings object class osqpSettings specifying settings osqp solver. details, refer osqp documentation (Stellato et al., 2020). ... Arguments passed ctcov mse TRUE (default) residuals used compute covariance matrix mean-corrected. shrink_fun Shrinkage function covariance matrix, shrink_estim (default).","code":""},{"path":"https://danigiro.github.io/FoReco/reference/ctlcc.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Level conditional coherent reconciliation for cross-temporal hierarchies — ctlcc","text":"(\\(n \\times h(k^\\ast+m)\\)) numeric matrix cross-temporal reconciled forecasts.","code":""},{"path":"https://danigiro.github.io/FoReco/reference/ctlcc.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Level conditional coherent reconciliation for cross-temporal hierarchies — ctlcc","text":"Byron, R.P. (1978), estimation large social account matrices, Journal Royal Statistical Society, Series , 141, 3, 359-367. doi:10.2307/2344807 Byron, R.P. (1979), Corrigenda: estimation large social account matrices, Journal Royal Statistical Society, Series , 142(3), 405. doi:10.2307/2982515 Di Fonzo, T. Girolimetto, D. (2024), Forecast combination-based forecast reconciliation: Insights extensions, International Journal Forecasting, 40(2), 490–514. doi:10.1016/j.ijforecast.2022.07.001 Di Fonzo, T. Girolimetto, D. (2023b) Spatio-temporal reconciliation solar forecasts. Solar Energy 251, 13–29. doi:10.1016/j.solener.2023.01.003 Hyndman, R.J., Ahmed, R.., Athanasopoulos, G. Shang, H.L. (2011), Optimal combination forecasts hierarchical time series, Computational Statistics & Data Analysis, 55, 9, 2579-2589. doi:10.1016/j.csda.2011.03.006 Hollyman, R., Petropoulos, F. Tipping, M.E. (2021), Understanding forecast reconciliation. European Journal Operational Research, 294, 149–160. doi:10.1016/j.ejor.2021.01.017 Stellato, B., Banjac, G., Goulart, P., Bemporad, . Boyd, S. (2020), OSQP: Operator Splitting solver Quadratic Programs, Mathematical Programming Computation, 12, 4, 637-672. doi:10.1007/s12532-020-00179-2","code":""},{"path":[]},{"path":"https://danigiro.github.io/FoReco/reference/ctlcc.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Level conditional coherent reconciliation for cross-temporal hierarchies — ctlcc","text":"","code":"set.seed(123) # Aggregation matrix for Z = X + Y, X = XX + XY and Y = YX + YY A <- matrix(c(1,1,1,1,1,1,0,0,0,0,1,1), 3, byrow = TRUE) # (7 x 7) base forecasts matrix (simulated), agg_order = 4 base <- rbind(rnorm(7, rep(c(40, 20, 10), c(1, 2, 4))),               rnorm(7, rep(c(20, 10, 5), c(1, 2, 4))),               rnorm(7, rep(c(20, 10, 5), c(1, 2, 4))),               rnorm(7, rep(c(10, 5, 2.5), c(1, 2, 4))),               rnorm(7, rep(c(10, 5, 2.5), c(1, 2, 4))),               rnorm(7, rep(c(10, 5, 2.5), c(1, 2, 4))),               rnorm(7, rep(c(10, 5, 2.5), c(1, 2, 4)))) # (7 x 70) in-sample residuals matrix (simulated) res <- matrix(rnorm(70*7), nrow = 7) # (4 x 4) Naive high frequency bottom base forecasts vector: # all forecasts are set equal to 2.5 naive <- matrix(2.5, 4, 4)  ## EXOGENOUS CONSTRAINTS (Hollyman et al., 2021) # Level Conditional Coherent (LCC) reconciled forecasts exo_LC <- ctlcc(base = base, agg_mat = A, agg_order = 4, comb = \"wlsh\", nn = \"osqp\",                 hfbts = naive, res = res, nodes = \"auto\", CCC = FALSE)  # Combined Conditional Coherent (CCC) reconciled forecasts exo_CCC <- ctlcc(base = base, agg_mat = A, agg_order = 4, comb = \"wlsh\",                 hfbts = naive, res = res, nodes = \"auto\", CCC = TRUE)  # Results detailed by level: info_exo <- recoinfo(exo_CCC, verbose = FALSE) # info_exo$lcc  ## ENDOGENOUS CONSTRAINTS (Di Fonzo and Girolimetto, 2024) # Level Conditional Coherent (LCC) reconciled forecasts endo_LC <- ctlcc(base = base, agg_mat = A, agg_order = 4, comb = \"wlsh\",                  res = res, nodes = \"auto\", CCC = FALSE,                  const = \"endogenous\")  # Combined Conditional Coherent (CCC) reconciled forecasts endo_CCC <- ctlcc(base = base, agg_mat = A, agg_order = 4, comb = \"wlsh\",                   res = res, nodes = \"auto\", CCC = TRUE,                   const = \"endogenous\")  # Results detailed by level: info_endo <- recoinfo(endo_CCC, verbose = FALSE) # info_endo$lcc"},{"path":"https://danigiro.github.io/FoReco/reference/ctmo.html","id":null,"dir":"Reference","previous_headings":"","what":"Cross-temporal middle-out reconciliation — ctmo","title":"Cross-temporal middle-out reconciliation — ctmo","text":"cross-temporal middle-forecast reconciliation combines top-(cttd) bottom-(ctbu) methods cross-temporal framework genuine hierarchical/grouped time series. Given base forecasts intermediate cross-sectional level \\(l\\) aggregation order \\(k\\), performs top-approach aggregation orders \\(\\geq k\\) cross-sectional levels \\(\\geq l\\); bottom-approach, otherwise.","code":""},{"path":"https://danigiro.github.io/FoReco/reference/ctmo.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Cross-temporal middle-out reconciliation — ctmo","text":"","code":"ctmo(base, agg_mat, agg_order, id_rows = 1, order = max(agg_order),      weights, tew = \"sum\", normalize = TRUE)"},{"path":"https://danigiro.github.io/FoReco/reference/ctmo.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Cross-temporal middle-out reconciliation — ctmo","text":"base (\\(n_l \\times hk\\)) numeric matrix containing \\(l\\)-level base forecasts temporal aggregation order \\(k\\); \\(n_l\\) number variables level \\(l\\), \\(k\\) aggregation order (factor \\(m\\), \\(1<k<m\\)), \\(m\\) max aggregation order, \\(h\\) forecast horizon lowest frequency time series. agg_mat (\\(n_a \\times n_b\\)) numeric matrix representing cross-sectional aggregation matrix. maps \\(n_b\\) bottom-level (free) variables \\(n_a\\) upper (constrained) variables. agg_order Highest available sampling frequency per seasonal cycle (max. order temporal aggregation, \\(m\\)), vector representing subset \\(p\\) factors \\(m\\). id_rows numeric vector indicating \\(l\\)-level rows agg_mat. order intermediate fixed aggregation order \\(k\\). weights (\\(n_b \\times hm\\)) numeric matrix containing proportions high-frequency bottom time series; \\(n_b\\) total number high-frequency bottom variables, \\(m\\) max aggregation order, \\(h\\) forecast horizon lowest frequency time series. tew string specifying type temporal aggregation. Options include: \"sum\" (simple summation, default), \"avg\" (average), \"first\" (first value period), \"last\" (last value period). normalize TRUE (default), weights sum 1.","code":""},{"path":"https://danigiro.github.io/FoReco/reference/ctmo.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Cross-temporal middle-out reconciliation — ctmo","text":"(\\(n \\times h(k^\\ast+m)\\)) numeric matrix cross-temporal reconciled forecasts.","code":""},{"path":[]},{"path":"https://danigiro.github.io/FoReco/reference/ctmo.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Cross-temporal middle-out reconciliation — ctmo","text":"","code":"set.seed(123) # Aggregation matrix for Z = X + Y, X = XX + XY and Y = YX + YY A <- matrix(c(1,1,1,1,1,1,0,0,0,0,1,1), 3, byrow = TRUE) # (2 x 6) base forecasts matrix (simulated), forecast horizon = 3 # and intermediate aggregation order k = 2 (max agg order = 4) baseL2k2 <- rbind(rnorm(3*2, 5), rnorm(3*2, 5))  # Same weights for different forecast horizons, agg_order = 4 fix_weights <- matrix(runif(4*4), 4, 4) reco <- ctmo(base = baseL2k2, id_rows = 2:3, agg_mat = A,              order = 2, agg_order = 4, weights = fix_weights)  # Different weights for different forecast horizons h_weights <- matrix(runif(4*4*3), 4, 3*4) recoh <- ctmo(base = baseL2k2, id_rows = 2:3, agg_mat = A,              order = 2, agg_order = 4, weights = h_weights)"},{"path":"https://danigiro.github.io/FoReco/reference/ctprojmat.html","id":null,"dir":"Reference","previous_headings":"","what":"Projection matrix for optimal combination cross-temporal reconciliation — ctprojmat","title":"Projection matrix for optimal combination cross-temporal reconciliation — ctprojmat","text":"function computes projection mapping matrix \\(\\mathbf{M}\\) \\(\\mathbf{G}\\), respectively, \\(\\widetilde{\\mathbf{y}} = \\mathbf{M}\\widehat{\\mathbf{y}} = \\mathbf{S}_{ct}\\mathbf{G}\\widehat{\\mathbf{y}}\\), \\(\\widetilde{\\mathbf{y}}\\) vector reconciled forecasts, \\(\\widehat{\\mathbf{y}}\\) vector base forecasts, \\(\\mathbf{S}_{ct}\\) cross-temporal structural matrix, \\(\\mathbf{M} = \\mathbf{S}_{ct}\\mathbf{G}\\). information regarding structure matrices, refer Girolimetto et al. (2023).","code":""},{"path":"https://danigiro.github.io/FoReco/reference/ctprojmat.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Projection matrix for optimal combination cross-temporal reconciliation — ctprojmat","text":"","code":"ctprojmat(agg_mat, cons_mat, agg_order, comb = \"ols\", res = NULL,           mat = \"M\", tew = \"sum\", ...)"},{"path":"https://danigiro.github.io/FoReco/reference/ctprojmat.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Projection matrix for optimal combination cross-temporal reconciliation — ctprojmat","text":"agg_mat (\\(n_a \\times n_b\\)) numeric matrix representing cross-sectional aggregation matrix. maps \\(n_b\\) bottom-level (free) variables \\(n_a\\) upper (constrained) variables. cons_mat (\\(n_a \\times n\\)) numeric matrix representing cross-sectional zero constraints. spans null space reconciled forecasts. agg_order Highest available sampling frequency per seasonal cycle (max. order temporal aggregation, \\(m\\)), vector representing subset \\(p\\) factors \\(m\\). comb string specifying reconciliation method. complete list, see ctcov. res (\\(n \\times N(k^\\ast+m)\\)) optional numeric matrix containing -sample residuals temporal frequencies ordered lowest frequency highest frequency (columns) variable (rows). matrix used compute covariance matrices. mat string specifying matrix return: \"M\" (default) \\(\\mathbf{M}\\) \"G\" \\(\\mathbf{G}\\). tew string specifying type temporal aggregation. Options include: \"sum\" (simple summation, default), \"avg\" (average), \"first\" (first value period), \"last\" (last value period). ... Arguments passed ctcov mse TRUE (default) residuals used compute covariance matrix mean-corrected. shrink_fun Shrinkage function covariance matrix, shrink_estim (default).","code":""},{"path":"https://danigiro.github.io/FoReco/reference/ctprojmat.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Projection matrix for optimal combination cross-temporal reconciliation — ctprojmat","text":"projection matrix \\(\\mathbf{M}\\) (mat = \"M\") mapping matrix \\(\\mathbf{G}\\) (mat = \"G\").","code":""},{"path":"https://danigiro.github.io/FoReco/reference/ctprojmat.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Projection matrix for optimal combination cross-temporal reconciliation — ctprojmat","text":"Girolimetto, D., Athanasopoulos, G., Di Fonzo, T. Hyndman, R.J. (2024), Cross-temporal probabilistic forecast reconciliation: Methodological practical issues. International Journal Forecasting, 40, 3, 1134-1151. doi:10.1016/j.ijforecast.2023. 10.003","code":""},{"path":[]},{"path":"https://danigiro.github.io/FoReco/reference/ctprojmat.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Projection matrix for optimal combination cross-temporal reconciliation — ctprojmat","text":"","code":"# Cross-temporal framework (Z = X + Y, annual-quarterly) A <- t(c(1,1)) # Aggregation matrix for Z = X + Y Mct <- ctprojmat(agg_mat = A, agg_order = 4, comb = \"ols\") Gct <- ctprojmat(agg_mat = A, agg_order = 4, comb = \"ols\", mat = \"G\")"},{"path":"https://danigiro.github.io/FoReco/reference/ctrec.html","id":null,"dir":"Reference","previous_headings":"","what":"Optimal combination cross-temporal reconciliation — ctrec","title":"Optimal combination cross-temporal reconciliation — ctrec","text":"function performs optimal (least squares sense) combination cross-temporal forecast reconciliation (Di Fonzo Girolimetto 2023a, Girolimetto et al. 2023). reconciled forecasts calculated using either projection approach (Byron, 1978, 1979) equivalent structural approach Hyndman et al. (2011). Non-negative (Di Fonzo Girolimetto, 2023) immutable reconciled forecasts can considered.","code":""},{"path":"https://danigiro.github.io/FoReco/reference/ctrec.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Optimal combination cross-temporal reconciliation — ctrec","text":"","code":"ctrec(base, agg_mat, cons_mat, agg_order, comb = \"ols\", res = NULL,       tew = \"sum\", approach = \"proj\", nn = NULL, settings = NULL,       bounds = NULL, immutable = NULL, ...)"},{"path":"https://danigiro.github.io/FoReco/reference/ctrec.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Optimal combination cross-temporal reconciliation — ctrec","text":"base (\\(n \\times h(k^\\ast+m)\\)) numeric matrix containing base forecasts reconciled; \\(n\\) total number variables, \\(m\\) max. order temporal aggregation, \\(k^\\ast\\) sum (subset ) (\\(p-1\\)) factors \\(m\\), excluding \\(m\\), \\(h\\) forecast horizon lowest frequency time series. row identifies time series, forecasts row ordered lowest frequency (temporally aggregated) highest frequency. agg_mat (\\(n_a \\times n_b\\)) numeric matrix representing cross-sectional aggregation matrix. maps \\(n_b\\) bottom-level (free) variables \\(n_a\\) upper (constrained) variables. cons_mat (\\(n_a \\times n\\)) numeric matrix representing cross-sectional zero constraints. spans null space reconciled forecasts. agg_order Highest available sampling frequency per seasonal cycle (max. order temporal aggregation, \\(m\\)), vector representing subset \\(p\\) factors \\(m\\). comb string specifying reconciliation method. complete list, see ctcov. res (\\(n \\times N(k^\\ast+m)\\)) optional numeric matrix containing -sample residuals temporal frequencies ordered lowest frequency highest frequency (columns) variable (rows). matrix used compute covariance matrices. tew string specifying type temporal aggregation. Options include: \"sum\" (simple summation, default), \"avg\" (average), \"first\" (first value period), \"last\" (last value period). approach string specifying approach used compute reconciled forecasts. Options include: \"proj\" (default): Projection approach according Byron (1978, 1979). \"strc\": Structural approach proposed Hyndman et al. (2011). \"proj_osqp\": Numerical solution using osqp projection approach. \"strc_osqp\": Numerical solution using osqp structural approach. nn string specifying algorithm compute non-negative reconciled forecasts: \"osqp\": quadratic programming optimization (osqp solver). \"sntz\": heuristic \"set-negative--zero\" (Di Fonzo Girolimetto, 2023). settings object class osqpSettings specifying settings osqp solver. details, refer osqp documentation (Stellato et al., 2020). bounds (\\(n(k^\\ast + m) \\times 2\\)) numeric matrix specifying cross-temporal bounds. first column represents lower bound, second column represents upper bound. immutable matrix three columns (\\(,k,j\\)), Column 1 Represents cross-sectional series (\\(= 1, \\dots, n\\)). Column 2 Denotes temporal aggregation order (\\(k = m,\\dots,1\\)). Column 3 Indicates temporal forecast horizon (\\(j = 1,\\dots,m/k\\)). example, working quarterly multivariate time series (\\(n = 3\\)): t(c(1, 4, 1)) - Fix one step ahead annual forecast first time series. t(c(2, 1, 2)) - Fix two step ahead quarterly forecast second time series. ... Arguments passed ctcov mse TRUE (default) residuals used compute covariance matrix mean-corrected. shrink_fun Shrinkage function covariance matrix, shrink_estim (default).","code":""},{"path":"https://danigiro.github.io/FoReco/reference/ctrec.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Optimal combination cross-temporal reconciliation — ctrec","text":"(\\(n \\times h(k^\\ast+m)\\)) numeric matrix cross-temporal reconciled forecasts.","code":""},{"path":"https://danigiro.github.io/FoReco/reference/ctrec.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Optimal combination cross-temporal reconciliation — ctrec","text":"Byron, R.P. (1978), estimation large social account matrices, Journal Royal Statistical Society, Series , 141, 3, 359-367. doi:10.2307/2344807 Byron, R.P. (1979), Corrigenda: estimation large social account matrices, Journal Royal Statistical Society, Series , 142(3), 405. doi:10.2307/2982515 Di Fonzo, T. Girolimetto, D. (2023a), Cross-temporal forecast reconciliation: Optimal combination method heuristic alternatives, International Journal Forecasting, 39, 1, 39-57. doi:10.1016/j.ijforecast.2021.08.004 Di Fonzo, T. Girolimetto, D. (2023), Spatio-temporal reconciliation solar forecasts, Solar Energy, 251, 13–29. doi:10.1016/j.solener.2023.01.003 Girolimetto, D., Athanasopoulos, G., Di Fonzo, T. Hyndman, R.J. (2024), Cross-temporal probabilistic forecast reconciliation: Methodological practical issues. International Journal Forecasting, 40, 3, 1134-1151. doi:10.1016/j.ijforecast.2023. 10.003 Hyndman, R.J., Ahmed, R.., Athanasopoulos, G. Shang, H.L. (2011), Optimal combination forecasts hierarchical time series, Computational Statistics & Data Analysis, 55, 9, 2579-2589. doi:10.1016/j.csda.2011.03.006 Stellato, B., Banjac, G., Goulart, P., Bemporad, . Boyd, S. (2020), OSQP: Operator Splitting solver Quadratic Programs, Mathematical Programming Computation, 12, 4, 637-672. doi:10.1007/s12532-020-00179-2","code":""},{"path":[]},{"path":"https://danigiro.github.io/FoReco/reference/ctrec.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Optimal combination cross-temporal reconciliation — ctrec","text":"","code":"set.seed(123) # (3 x 7) base forecasts matrix (simulated), Z = X + Y and m = 4 base <- rbind(rnorm(7, rep(c(20, 10, 5), c(1, 2, 4))),               rnorm(7, rep(c(10, 5, 2.5), c(1, 2, 4))),               rnorm(7, rep(c(10, 5, 2.5), c(1, 2, 4)))) # (3 x 70) in-sample residuals matrix (simulated) res <- rbind(rnorm(70), rnorm(70), rnorm(70))  A <- t(c(1,1)) # Aggregation matrix for Z = X + Y m <- 4 # from quarterly to annual temporal aggregation reco <- ctrec(base = base, agg_mat = A, agg_order = m, comb = \"wlsv\", res = res)  C <- t(c(1, -1, -1)) # Zero constraints matrix for Z - X - Y = 0 reco <- ctrec(base = base, cons_mat = C, agg_order = m, comb = \"wlsv\", res = res)  # Immutable reconciled forecasts # Fix all the quarterly forecasts of the second variable. imm_mat <- expand.grid(i = 2, k = 1, j = 1:4) immreco <- ctrec(base = base, cons_mat = C, agg_order = m, comb = \"wlsv\",                  res = res, immutable = imm_mat)  # Non negative reconciliation base[2,7] <- -2*base[2,7] # Making negative one of the quarterly base forecasts for variable X nnreco <- ctrec(base = base, cons_mat = C, agg_order = m, comb = \"wlsv\",                 res = res, nn = \"osqp\") recoinfo(nnreco, verbose = FALSE)$info #>     obj_val   run_time iter      pri_res status status_polish #> 1 -635.7645 9.3916e-05   25 1.284524e-15      1             1"},{"path":"https://danigiro.github.io/FoReco/reference/cttd.html","id":null,"dir":"Reference","previous_headings":"","what":"Cross-temporal top-down reconciliation — cttd","title":"Cross-temporal top-down reconciliation — cttd","text":"Top-forecast reconciliation cross-temporal hierarchical/grouped time series, forecast `Total' (top-level series, expected positive) disaggregated according proportional scheme (weights). Besides fulfilling aggregation constraint, top-reconciled forecasts respect two main properties: top-level value remains unchanged; bottom time series reconciled forecasts non-negative.","code":""},{"path":"https://danigiro.github.io/FoReco/reference/cttd.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Cross-temporal top-down reconciliation — cttd","text":"","code":"cttd(base, agg_mat, agg_order, weights, tew = \"sum\", normalize = TRUE)"},{"path":"https://danigiro.github.io/FoReco/reference/cttd.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Cross-temporal top-down reconciliation — cttd","text":"base (\\(hm \\times 1\\)) numeric vector containing top- \\(m\\) temporal aggregated level base forecasts; \\(m\\) max aggregation order, \\(h\\) forecast horizon lowest frequency time series. agg_mat (\\(n_a \\times n_b\\)) numeric matrix representing cross-sectional aggregation matrix. maps \\(n_b\\) bottom-level (free) variables \\(n_a\\) upper (constrained) variables. agg_order Highest available sampling frequency per seasonal cycle (max. order temporal aggregation, \\(m\\)), vector representing subset \\(p\\) factors \\(m\\). weights (\\(n_b \\times hm\\)) numeric matrix containing proportions high-frequency bottom time series; \\(n_b\\) total number high-frequency bottom variables, \\(m\\) max aggregation order, \\(h\\) forecast horizon lowest frequency time series. tew string specifying type temporal aggregation. Options include: \"sum\" (simple summation, default), \"avg\" (average), \"first\" (first value period), \"last\" (last value period). normalize TRUE (default), weights sum 1.","code":""},{"path":"https://danigiro.github.io/FoReco/reference/cttd.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Cross-temporal top-down reconciliation — cttd","text":"(\\(n \\times h(k^\\ast+m)\\)) numeric matrix cross-temporal reconciled forecasts.","code":""},{"path":[]},{"path":"https://danigiro.github.io/FoReco/reference/cttd.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Cross-temporal top-down reconciliation — cttd","text":"","code":"set.seed(123) # (3 x 1) top base forecasts vector (simulated), forecast horizon = 3 topf <- rnorm(3, 10) A <- t(c(1,1)) # Aggregation matrix for Z = X + Y  # Same weights for different forecast horizons, agg_order = 4 fix_weights <- matrix(runif(4*2), 2, 4) reco <- cttd(base = topf, agg_mat = A, agg_order = 4, weights = fix_weights)  # Different weights for different forecast horizons h_weights <- matrix(runif(4*2*3), 2, 3*4) recoh <- cttd(base = topf, agg_mat = A, agg_order = 4, weights = h_weights)"},{"path":"https://danigiro.github.io/FoReco/reference/cttools.html","id":null,"dir":"Reference","previous_headings":"","what":"Cross-temporal reconciliation tools — cttools","title":"Cross-temporal reconciliation tools — cttools","text":"useful tools cross-temporal forecast reconciliation linearly constrained (e.g., hierarchical/grouped) multiple time series.","code":""},{"path":"https://danigiro.github.io/FoReco/reference/cttools.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Cross-temporal reconciliation tools — cttools","text":"","code":"cttools(agg_mat, cons_mat, agg_order, tew = \"sum\", fh = 1, sparse = TRUE)"},{"path":"https://danigiro.github.io/FoReco/reference/cttools.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Cross-temporal reconciliation tools — cttools","text":"agg_mat (\\(n_a \\times n_b\\)) numeric matrix representing cross-sectional aggregation matrix. maps \\(n_b\\) bottom-level (free) variables \\(n_a\\) upper (constrained) variables. cons_mat (\\(n_a \\times n\\)) numeric matrix representing cross-sectional zero constraints. spans null space reconciled forecasts. agg_order Highest available sampling frequency per seasonal cycle (max. order temporal aggregation, \\(m\\)), vector representing subset \\(p\\) factors \\(m\\). tew string specifying type temporal aggregation. Options include: \"sum\" (simple summation, default), \"avg\" (average), \"first\" (first value period), \"last\" (last value period). fh Forecast horizon lowest frequency (temporally aggregated) time series (default 1). sparse Option return sparse matrices (default TRUE).","code":""},{"path":"https://danigiro.github.io/FoReco/reference/cttools.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Cross-temporal reconciliation tools — cttools","text":"list four elements: dim vector containing information number series complete system (n), upper levels (na) bottom level (nb), maximum aggregation order  (m), number factor (p), partial (ks) total sum (kt) factors. set vector temporal aggregation orders (decreasing order). agg_mat cross-temporal aggregation matrix. strc_mat cross-temporal structural matrix. cons_mat cross-temporal zero constraints matrix.","code":""},{"path":[]},{"path":"https://danigiro.github.io/FoReco/reference/cttools.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Cross-temporal reconciliation tools — cttools","text":"","code":"# Cross-temporal framework A <- t(c(1,1)) # Aggregation matrix for Z = X + Y m <- 4 # from quarterly to annual temporal aggregation cttools(agg_mat = A, agg_order = m) #> $dim #>  n na nb  m  p ks kt  #>  3  1  2  4  3  3  7  #>  #> $set #> [1] 4 2 1 #>  #> $agg_mat #> 13 x 8 sparse Matrix of class \"dgCMatrix\" #>                       #>  [1,] 1 1 1 1 1 1 1 1 #>  [2,] 1 1 . . 1 1 . . #>  [3,] . . 1 1 . . 1 1 #>  [4,] 1 . . . 1 . . . #>  [5,] . 1 . . . 1 . . #>  [6,] . . 1 . . . 1 . #>  [7,] . . . 1 . . . 1 #>  [8,] 1 1 1 1 . . . . #>  [9,] 1 1 . . . . . . #> [10,] . . 1 1 . . . . #> [11,] . . . . 1 1 1 1 #> [12,] . . . . 1 1 . . #> [13,] . . . . . . 1 1 #>  #> $strc_mat #> 21 x 8 sparse Matrix of class \"dgCMatrix\" #>                       #>  [1,] 1 1 1 1 1 1 1 1 #>  [2,] 1 1 . . 1 1 . . #>  [3,] . . 1 1 . . 1 1 #>  [4,] 1 . . . 1 . . . #>  [5,] . 1 . . . 1 . . #>  [6,] . . 1 . . . 1 . #>  [7,] . . . 1 . . . 1 #>  [8,] 1 1 1 1 . . . . #>  [9,] 1 1 . . . . . . #> [10,] . . 1 1 . . . . #> [11,] 1 . . . . . . . #> [12,] . 1 . . . . . . #> [13,] . . 1 . . . . . #> [14,] . . . 1 . . . . #> [15,] . . . . 1 1 1 1 #> [16,] . . . . 1 1 . . #> [17,] . . . . . . 1 1 #> [18,] . . . . 1 . . . #> [19,] . . . . . 1 . . #> [20,] . . . . . . 1 . #> [21,] . . . . . . . 1 #>  #> $cons_mat #> 13 x 21 sparse Matrix of class \"dgCMatrix\" #>                                                             #>  [1,] . . .  1  .  .  . . . . -1  .  .  . . . . -1  .  .  . #>  [2,] . . .  .  1  .  . . . .  . -1  .  . . . .  . -1  .  . #>  [3,] . . .  .  .  1  . . . .  .  . -1  . . . .  .  . -1  . #>  [4,] . . .  .  .  .  1 . . .  .  .  . -1 . . .  .  .  . -1 #>  [5,] 1 . . -1 -1 -1 -1 . . .  .  .  .  . . . .  .  .  .  . #>  [6,] . 1 . -1 -1  .  . . . .  .  .  .  . . . .  .  .  .  . #>  [7,] . . 1  .  . -1 -1 . . .  .  .  .  . . . .  .  .  .  . #>  [8,] . . .  .  .  .  . 1 . . -1 -1 -1 -1 . . .  .  .  .  . #>  [9,] . . .  .  .  .  . . 1 . -1 -1  .  . . . .  .  .  .  . #> [10,] . . .  .  .  .  . . . 1  .  . -1 -1 . . .  .  .  .  . #> [11,] . . .  .  .  .  . . . .  .  .  .  . 1 . . -1 -1 -1 -1 #> [12,] . . .  .  .  .  . . . .  .  .  .  . . 1 . -1 -1  .  . #> [13,] . . .  .  .  .  . . . .  .  .  .  . . . 1  .  . -1 -1 #>"},{"path":"https://danigiro.github.io/FoReco/reference/df2aggmat.html","id":null,"dir":"Reference","previous_headings":"","what":"Cross-sectional aggregation matrix of a dataframe — df2aggmat","title":"Cross-sectional aggregation matrix of a dataframe — df2aggmat","text":"function allows user easily build (\\(n_a \\times n_b\\)) cross-sectional aggregation matrix starting data frame.","code":""},{"path":"https://danigiro.github.io/FoReco/reference/df2aggmat.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Cross-sectional aggregation matrix of a dataframe — df2aggmat","text":"","code":"df2aggmat(formula, data, sep = \"_\", sparse = TRUE, top_label = \"Total\",           verbose = TRUE)"},{"path":"https://danigiro.github.io/FoReco/reference/df2aggmat.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Cross-sectional aggregation matrix of a dataframe — df2aggmat","text":"formula Specification hierarchical structure: grouped hierarchies specified using ~ g1 * g2 nested hierarchies specified using ~ parent / child. Mixtures two formulations also possible, like ~ g1 * (grandparent / parent / child). data dataset column contains values variables formula row identifies bottom level time series. sep Character separate names aggregated series, (default \"_\"). sparse Option return sparse matrices (default TRUE). top_label Label top level variable (default \"Total\"). verbose TRUE (default), hierarchy informations printed.","code":""},{"path":"https://danigiro.github.io/FoReco/reference/df2aggmat.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Cross-sectional aggregation matrix of a dataframe — df2aggmat","text":"(na x nb) matrix.","code":""},{"path":[]},{"path":"https://danigiro.github.io/FoReco/reference/df2aggmat.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Cross-sectional aggregation matrix of a dataframe — df2aggmat","text":"","code":"## Balanced hierarchy #         T #    |--------| #    A        B #  |---|   |--|--| # AA   AB  BA BB BC # Names of the bottom level variables data_bts <- data.frame(X1 = c(\"A\", \"A\", \"B\", \"B\", \"B\"),                        X2 = c(\"A\", \"B\", \"A\", \"B\", \"C\"),                        stringsAsFactors = FALSE) # Cross-sectional aggregation matrix agg_mat <- df2aggmat(~ X1 / X2, data_bts, sep = \"\", verbose = FALSE)  ## Unbalanced hierarchy #                 T #       |---------|---------| #       A         B         C #     |---|     |---|     |---| #    AA   AB   BA   BB   CA   CB #  |----|         |----| # AAA  AAB       BBA  BBB # Names of the bottom level variables data_bts <- data.frame(X1 = c(\"A\", \"A\", \"A\", \"B\", \"B\", \"B\", \"C\", \"C\"),                        X2 = c(\"A\", \"A\", \"B\", \"A\", \"B\", \"B\", \"A\", \"B\"),                        X3 = c(\"A\", \"B\", NA, NA, \"A\", \"B\", NA, NA),                        stringsAsFactors = FALSE) # Cross-sectional aggregation matrix agg_mat <- df2aggmat(~ X1 / X2 / X3, data_bts, sep = \"\", verbose = FALSE)  ## Group of two hierarchies #     T          T         T | A  | B  | C #  |--|--|  X  |---|  ->  ---+----+----+---- #  A  B  C     M   F       M | AM | BM | CM #                          F | AF | BF | CF # Names of the bottom level variables data_bts <- data.frame(X1 = c(\"A\", \"A\", \"B\", \"B\", \"C\", \"C\"),                        Y1 = c(\"M\", \"F\", \"M\", \"F\", \"M\", \"F\"),                        stringsAsFactors = FALSE) # Cross-sectional aggregation matrix agg_mat <- df2aggmat(~ Y1 * X1, data_bts, sep = \"\", verbose = FALSE)"},{"path":"https://danigiro.github.io/FoReco/reference/heuristic-reco.html","id":null,"dir":"Reference","previous_headings":"","what":"Heuristic cross-temporal reconciliation — tcsrec","title":"Heuristic cross-temporal reconciliation — tcsrec","text":"tcsrec replicates procedure Kourentzes Athanasopoulos (2019): () time series forecasts temporal aggregation order reconciled using temporal hierarchies; (ii) time--time cross-sectional reconciliation performed; (iii) projection matrices obtained step (ii) averaged used cross-sectionally reconcile forecasts obtained step (). cstrec, order application two reconciliation steps (temporal first, cross-sectional), inverted compared tcsrec (Di Fonzo Girolimetto, 2023).","code":""},{"path":"https://danigiro.github.io/FoReco/reference/heuristic-reco.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Heuristic cross-temporal reconciliation — tcsrec","text":"","code":"# First-temporal-then-cross-sectional forecast reconciliation tcsrec(base, cslist, telist, res = NULL, avg = \"KA\")  # First-cross-sectional-then-temporal forecast reconciliation cstrec(base, cslist, telist, res = NULL)"},{"path":"https://danigiro.github.io/FoReco/reference/heuristic-reco.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Heuristic cross-temporal reconciliation — tcsrec","text":"base (\\(n \\times h(k^\\ast+m)\\)) numeric matrix containing base forecasts reconciled; \\(n\\) total number variables, \\(m\\) max. order temporal aggregation, \\(k^\\ast\\) sum (subset ) (\\(p-1\\)) factors \\(m\\), excluding \\(m\\), \\(h\\) forecast horizon lowest frequency time series. row identifies time series, forecasts row ordered lowest frequency (temporally aggregated) highest frequency. cslist list elements cross-sectional reconciliation. See csrec complete list (excluded base res). telist list elements temporal reconciliation. See terec complete list (excluded base res). res (\\(n \\times N(k^\\ast+m)\\)) optional numeric matrix containing -sample residuals temporal frequencies ordered lowest frequency highest frequency (columns) variable (rows). matrix used compute covariance matrices. avg avg = \"KA\" (default), final projection matrix \\(\\mathbf{M}\\) one proposed Kourentzes Athanasopoulos (2019), otherwise calculated simple average involved projection matrices step 2 procedure (see Di Fonzo Girolimetto, 2023).","code":""},{"path":"https://danigiro.github.io/FoReco/reference/heuristic-reco.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Heuristic cross-temporal reconciliation — tcsrec","text":"(\\(n \\times h(k^\\ast+m)\\)) numeric matrix cross-temporal reconciled forecasts.","code":""},{"path":"https://danigiro.github.io/FoReco/reference/heuristic-reco.html","id":"warning","dir":"Reference","previous_headings":"","what":"Warning","title":"Heuristic cross-temporal reconciliation — tcsrec","text":"two-step heuristic reconciliation allows considering non negativity constraints first step. means non-negativity guaranteed final reconciled values.","code":""},{"path":"https://danigiro.github.io/FoReco/reference/heuristic-reco.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Heuristic cross-temporal reconciliation — tcsrec","text":"Di Fonzo, T. Girolimetto, D. (2023), Cross-temporal forecast reconciliation: Optimal combination method heuristic alternatives, International Journal Forecasting, 39, 1, 39-57. doi:10.1016/j.ijforecast.2021.08.004 Kourentzes, N. Athanasopoulos, G. (2019), Cross-temporal coherent forecasts Australian tourism, Annals Tourism Research, 75, 393-409. doi:10.1016/j.annals.2019.02.001","code":""},{"path":[]},{"path":"https://danigiro.github.io/FoReco/reference/heuristic-reco.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Heuristic cross-temporal reconciliation — tcsrec","text":"","code":"set.seed(123) # (3 x 7) base forecasts matrix (simulated), Z = X + Y and m = 4 base <- rbind(rnorm(7, rep(c(20, 10, 5), c(1, 2, 4))),               rnorm(7, rep(c(10, 5, 2.5), c(1, 2, 4))),               rnorm(7, rep(c(10, 5, 2.5), c(1, 2, 4)))) # (3 x 70) in-sample residuals matrix (simulated) res <- rbind(rnorm(70), rnorm(70), rnorm(70))  A <- t(c(1,1)) # Aggregation matrix for Z = X + Y m <- 4 # from quarterly to annual temporal aggregation  rtcs <- tcsrec(base = base,                cslist = list(agg_mat = A, comb = \"shr\"),                telist = list(agg_order = m, comb = \"wlsv\"),                res = res)  rcst <- tcsrec(base = base,                cslist = list(agg_mat = A, comb = \"shr\"),                telist = list(agg_order = m, comb = \"wlsv\"),                res = res)"},{"path":"https://danigiro.github.io/FoReco/reference/itagdp.html","id":null,"dir":"Reference","previous_headings":"","what":"Italian Quarterly National Accounts — itagdp","title":"Italian Quarterly National Accounts — itagdp","text":"subset data used Girolimetto et al. (2023) Italian Quarterly National Accounts (output, income expenditure sides) spanning period 2000:Q1-2019:Q4.","code":""},{"path":"https://danigiro.github.io/FoReco/reference/itagdp.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Italian Quarterly National Accounts — itagdp","text":"","code":"# 21 time series of the Italian Quarterly National Accounts itagdp  # 'agg_mat' and 'cons_mat' for the output side outside  # 'agg_mat' and 'cons_mat' for the expenditure side expside  # 'agg_mat' and 'cons_mat' for the income side incside  # zero constraints matrix encompassing output, expenditure and income sides gdpconsmat"},{"path":"https://danigiro.github.io/FoReco/reference/itagdp.html","id":"format","dir":"Reference","previous_headings":"","what":"Format","title":"Italian Quarterly National Accounts — itagdp","text":"itagdp \\((80 \\times 21)\\) ts object, corresponding 21 time series Italian Quarterly National Accounts (2000:Q1-2019:Q4). outside, income expenditure lists two elements: agg_mat contains \\((1 \\times 2)\\), \\((2 \\times 4)\\), \\((6 \\times 8)\\) aggregation matrix according output, income expenditure side, respectively. cons_mat contains \\((1 \\times 3)\\), \\((2 \\times 6)\\), \\((6 \\times 14)\\) zero constraints matrix according output, income expenditure side, respectively. gdpconsmat complete \\((9 \\times 21)\\) zero constraints matrix encompassing output, expenditure income sides.","code":""},{"path":"https://danigiro.github.io/FoReco/reference/itagdp.html","id":"source","dir":"Reference","previous_headings":"","what":"Source","title":"Italian Quarterly National Accounts — itagdp","text":"https://ec.europa.eu/eurostat/web/national-accounts/","code":""},{"path":"https://danigiro.github.io/FoReco/reference/itagdp.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Italian Quarterly National Accounts — itagdp","text":"Girolimetto, D. Di Fonzo, T. (2023), Point probabilistic forecast reconciliation general linearly constrained multiple time series, Statistical Methods & Applications, press. doi:10.1007/s10260-023-00738-6 .","code":""},{"path":"https://danigiro.github.io/FoReco/reference/iterec.html","id":null,"dir":"Reference","previous_headings":"","what":"Iterative cross-temporal reconciliation — iterec","title":"Iterative cross-temporal reconciliation — iterec","text":"function performs iterative procedure described Di Fonzo Girolimetto (2023), produces cross-temporally reconciled forecasts alternating forecast reconciliation along one single dimension (either cross-sectional temporal) iteration step.","code":""},{"path":"https://danigiro.github.io/FoReco/reference/iterec.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Iterative cross-temporal reconciliation — iterec","text":"","code":"iterec(base, cslist, telist, res = NULL, itmax = 100, tol = 1e-5,        type = \"tcs\", norm = \"inf\", verbose = TRUE)"},{"path":"https://danigiro.github.io/FoReco/reference/iterec.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Iterative cross-temporal reconciliation — iterec","text":"base (\\(n \\times h(k^\\ast+m)\\)) numeric matrix containing base forecasts reconciled; \\(n\\) total number variables, \\(m\\) max. order temporal aggregation, \\(k^\\ast\\) sum (subset ) (\\(p-1\\)) factors \\(m\\), excluding \\(m\\), \\(h\\) forecast horizon lowest frequency time series. row identifies time series, forecasts row ordered lowest frequency (temporally aggregated) highest frequency. cslist list elements cross-sectional reconciliation. See csrec complete list (excluded base res). telist list elements temporal reconciliation. See terec complete list (excluded base res). res (\\(n \\times N(k^\\ast+m)\\)) optional numeric matrix containing -sample residuals temporal frequencies ordered lowest frequency highest frequency (columns) variable (rows). matrix used compute covariance matrices. itmax Max number iteration (100, default). tol Convergence tolerance (1e-5, default). type string specifying uni-dimensional reconciliation order: temporal cross-sectional (\"tcs\") cross-sectional temporal (\"cst\"). norm Norm used calculate temporal cross-sectional incoherence: infinity norm (\"inf\", default), one norm (\"one\"), 2-norm (\"two\"). verbose TRUE, reconciliation information printed.","code":""},{"path":"https://danigiro.github.io/FoReco/reference/iterec.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Iterative cross-temporal reconciliation — iterec","text":"(\\(n \\times h(k^\\ast+m)\\)) numeric matrix cross-temporal reconciled forecasts.","code":""},{"path":"https://danigiro.github.io/FoReco/reference/iterec.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Iterative cross-temporal reconciliation — iterec","text":"Di Fonzo, T. Girolimetto, D. (2023), Cross-temporal forecast reconciliation: Optimal combination method heuristic alternatives, International Journal Forecasting, 39, 1, 39-57. doi:10.1016/j.ijforecast.2021.08.004","code":""},{"path":[]},{"path":"https://danigiro.github.io/FoReco/reference/iterec.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Iterative cross-temporal reconciliation — iterec","text":"","code":"set.seed(123) # (3 x 7) base forecasts matrix (simulated), Z = X + Y and m = 4 base <- rbind(rnorm(7, rep(c(20, 10, 5), c(1, 2, 4))),               rnorm(7, rep(c(10, 5, 2.5), c(1, 2, 4))),               rnorm(7, rep(c(10, 5, 2.5), c(1, 2, 4)))) # (3 x 70) in-sample residuals matrix (simulated) res <- rbind(rnorm(70), rnorm(70), rnorm(70))  A <- t(c(1,1)) # Aggregation matrix for Z = X + Y m <- 4 # from quarterly to annual temporal aggregation  rite <- iterec(base = base,                cslist = list(agg_mat = A, comb = \"shr\"),                telist = list(agg_order = m, comb = \"wlsv\"),                res = res) #> ── Iterative heuristic cross-temporal forecast reconciliation ────────────────── #> Legend: i = iteration; s = step. Norm = \"inf\". #>  #>   i.s |        Temporal | Cross-sectional | #>     0 |            3.36 |            1.79 | #>   1.1 |            0.00 |            1.91 | #>   1.2 |        2.02e-01 |            0.00 | #>   2.1 |            0.00 |        2.42e-02 | #>   2.2 |        2.56e-03 |            0.00 | #>   3.1 |            0.00 |        3.18e-04 | #>   3.2 |        3.37e-05 |            0.00 | #>   4.1 |            0.00 |        4.50e-06 | #>   4.2 |        4.62e-07 |            0.00 | #>  #> ✔ Convergence achieved at iteration 4. #> ────────────────────────────────────────────────────────────────────────────────"},{"path":"https://danigiro.github.io/FoReco/reference/lcmat.html","id":null,"dir":"Reference","previous_headings":"","what":"Linear combination (aggregation) matrix for a general linearly constrained multiple time series — lcmat","title":"Linear combination (aggregation) matrix for a general linearly constrained multiple time series — lcmat","text":"function transforms general (possibly redundant) zero constraints matrix linear combination (aggregation) matrix \\(\\mathbf{}_{cs}\\). working general linearly constrained multiple (\\(n\\)-variate) time series, getting linear combination matrix \\(\\mathbf{}_{cs}\\) critical step obtain structural-like representation $$\\mathbf{C}_{cs} = [\\mathbf{} \\quad -\\mathbf{}],$$ \\(\\mathbf{C}_{cs}\\) full rank zero constraints matrix (Girolimetto Di Fonzo, 2023).","code":""},{"path":"https://danigiro.github.io/FoReco/reference/lcmat.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Linear combination (aggregation) matrix for a general linearly constrained multiple time series — lcmat","text":"","code":"lcmat(cons_mat, method = \"rref\", tol = sqrt(.Machine$double.eps),        verbose = FALSE, sparse = TRUE)"},{"path":"https://danigiro.github.io/FoReco/reference/lcmat.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Linear combination (aggregation) matrix for a general linearly constrained multiple time series — lcmat","text":"cons_mat (\\(r \\times n\\)) numeric matrix representing cross-sectional zero constraints. method Method use: \"rref\" Reduced Row Echelon Form Gauss-Jordan elimination (default), \"qr\" (pivoting) QR decomposition (Strang, 2019). tol Tolerance \"rref\" \"qr\" method. verbose TRUE, intermediate steps printed (default FALSE). sparse Option return sparse matrix (default TRUE).","code":""},{"path":"https://danigiro.github.io/FoReco/reference/lcmat.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Linear combination (aggregation) matrix for a general linearly constrained multiple time series — lcmat","text":"list two elements: () linear combination (aggregation) matrix (agg_mat) (ii) vector column permutations (pivot).","code":""},{"path":"https://danigiro.github.io/FoReco/reference/lcmat.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Linear combination (aggregation) matrix for a general linearly constrained multiple time series — lcmat","text":"Girolimetto, D. Di Fonzo, T. (2023), Point probabilistic forecast reconciliation general linearly constrained multiple time series, Statistical Methods & Applications, press. doi:10.1007/s10260-023-00738-6 . Strang, G. (2019), Linear algebra learning data, Wellesley, Cambridge Press.","code":""},{"path":[]},{"path":"https://danigiro.github.io/FoReco/reference/lcmat.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Linear combination (aggregation) matrix for a general linearly constrained multiple time series — lcmat","text":"","code":"## Two hierarchy sharing the same top-level variable, but not sharing the bottom variables #        X            X #    |-------|    |-------| #    A       B    C       D #  |---| # A1   A2 # 1) X = C + D, # 2) X = A + B, # 3) A = A1 + A2. cons_mat <- matrix(c(1,-1,-1,0,0,0,0,                1,0,0,-1,-1,0,0,                0,0,0,1,0,-1,-1), nrow = 3, byrow = TRUE) obj <- lcmat(cons_mat = cons_mat, verbose = TRUE) #> ! A pivot is performed. Remember to apply the pivot also to the base forecast. #> ℹ E.g. `base[, pivot]` in cross-sectional or `base[pivot, ]` in cross-temporal. agg_mat <- obj$agg_mat # linear combination matrix pivot <- obj$pivot # Pivot vector"},{"path":"https://danigiro.github.io/FoReco/reference/recoinfo.html","id":null,"dir":"Reference","previous_headings":"","what":"Informations on the reconciliation process — recoinfo","title":"Informations on the reconciliation process — recoinfo","text":"function extracts reconciliation information output reconciled function implemented FoReco.","code":""},{"path":"https://danigiro.github.io/FoReco/reference/recoinfo.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Informations on the reconciliation process — recoinfo","text":"","code":"recoinfo(x, verbose = TRUE)"},{"path":"https://danigiro.github.io/FoReco/reference/recoinfo.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Informations on the reconciliation process — recoinfo","text":"x output reconciliation function implemented FoReco. verbose TRUE (defaults), reconciliation information printed.","code":""},{"path":"https://danigiro.github.io/FoReco/reference/recoinfo.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Informations on the reconciliation process — recoinfo","text":"list containing following reconciliation process informations: rfun reconciliation function. cs_n cross-sectional number variables. te_set set temporal aggregation orders. forecast_horizon forecast horizon (temporal cross-temporal frameworks, temporally aggregated series). framework reconciliation framework (cross-sectional, temporal cross-temporal). info non-negative reconciled forecast convergence information. lcc list level conditional reconciled forecasts (+ BU) cslcc, telcc ctlcc. nn TRUE, forecasts negative. comb covariance approximation.","code":""},{"path":[]},{"path":"https://danigiro.github.io/FoReco/reference/residuals.html","id":null,"dir":"Reference","previous_headings":"","what":"One-step and multi-step residuals — res2matrix","title":"One-step and multi-step residuals — res2matrix","text":"functions can used arrange residuals reconcile temporal cross-temporal forecasts. res2matrix takes input set temporal cross-temporal residuals re-organizes matrix rows correspond different forecast horizons, capturing temporal dimension. Meanwhile, columns ordered based specific arrangement described Di Fonzo Girolimetto (2023). arrange_hres takes input list multi-step residuals designed organize accordance time order (Girolimetto et al. 2023). applied, function ensures sequence multi-step residuals aligns chronological order occurred.","code":""},{"path":"https://danigiro.github.io/FoReco/reference/residuals.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"One-step and multi-step residuals — res2matrix","text":"","code":"res2matrix(res, agg_order)  arrange_hres(list_res)"},{"path":"https://danigiro.github.io/FoReco/reference/residuals.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"One-step and multi-step residuals — res2matrix","text":"res (\\(n \\times N(k^\\ast+m)\\)) numeric matrix (cross-temporal framework) (\\(N(k^\\ast+m) \\times 1\\)) numeric vector (temporal framework) representing -sample residuals temporal frequencies ordered lowest frequency highest frequency (columns) variable (rows). agg_order Highest available sampling frequency per seasonal cycle (max. order temporal aggregation, \\(m\\)), vector representing subset \\(p\\) factors \\(m\\). list_res list \\(H\\) multi-step residuals. element list can either (\\(T \\times 1\\)) vector (temporal framework) (\\(T \\times n\\)) matrix (cross-temporal framework).","code":""},{"path":"https://danigiro.github.io/FoReco/reference/residuals.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"One-step and multi-step residuals — res2matrix","text":"res2matrix returns (\\(N \\times n(k^\\ast + m)\\)) matrix, \\(n = 1\\) temporal framework. arrange_hres returns (\\(N(k^\\ast+m) \\times 1\\)) vector (temporal framework) (\\(n \\times N(k^\\ast+m)\\)) matrix  (cross-temporal framework) multi-step residuals.","code":""},{"path":"https://danigiro.github.io/FoReco/reference/residuals.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"One-step and multi-step residuals — res2matrix","text":"Let \\(Z_t\\), \\(t=1,\\dots,T\\), univariate time series. can define multi-step residuals us $$\\widehat{\\varepsilon}_{h,t} = Z_{t+h} - \\widehat{Z}_{t+h|t} \\qquad h \\le t \\le T-h$$ \\(\\widehat{Z}_{t+h|t}\\) \\(h\\)-step fitted value, calculated \\(h\\)-step ahead forecast condition information time \\(t\\). Given list errors different steps $$\\left([\\widehat{\\varepsilon}_{1,1}, \\; \\dots, \\; \\widehat{\\varepsilon}_{1,T}], \\dots, [\\widehat{\\varepsilon}_{H,1}, \\; \\dots, \\; \\widehat{\\varepsilon}_{H,T}]\\right),$$ arrange_hres returns \\(T\\)-vector residuals, organized following way: $$[\\varepsilon_{1,1} \\; \\varepsilon_{2,2} \\; \\dots \\; \\varepsilon_{H,H} \\; \\varepsilon_{1,H+1} \\; \\dots \\; \\varepsilon_{H,T-H}]'$$ similar organisation can apply multivariate time series.","code":""},{"path":"https://danigiro.github.io/FoReco/reference/residuals.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"One-step and multi-step residuals — res2matrix","text":"Di Fonzo, T. Girolimetto, D. (2023), Cross-temporal forecast reconciliation: Optimal combination method heuristic alternatives, International Journal Forecasting, 39, 1, 39-57. doi:10.1016/j.ijforecast.2021.08.004 Girolimetto, D., Athanasopoulos, G., Di Fonzo, T. Hyndman, R.J. (2024), Cross-temporal probabilistic forecast reconciliation: Methodological practical issues. International Journal Forecasting, 40, 3, 1134-1151. doi:10.1016/j.ijforecast.2023. 10.003","code":""},{"path":[]},{"path":"https://danigiro.github.io/FoReco/reference/shrink_estim.html","id":null,"dir":"Reference","previous_headings":"","what":"Shrinkage of the covariance matrix — shrink_estim","title":"Shrinkage of the covariance matrix — shrink_estim","text":"Shrinkage covariance matrix according Schäfer Strimmer (2005).","code":""},{"path":"https://danigiro.github.io/FoReco/reference/shrink_estim.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Shrinkage of the covariance matrix — shrink_estim","text":"","code":"shrink_estim(x, mse = TRUE)"},{"path":"https://danigiro.github.io/FoReco/reference/shrink_estim.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Shrinkage of the covariance matrix — shrink_estim","text":"x numeric matrix containing -sample residuals. mse TRUE (default), residuals used compute covariance matrix mean-corrected.","code":""},{"path":"https://danigiro.github.io/FoReco/reference/shrink_estim.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Shrinkage of the covariance matrix — shrink_estim","text":"shrunk covariance matrix.","code":""},{"path":"https://danigiro.github.io/FoReco/reference/shrink_estim.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Shrinkage of the covariance matrix — shrink_estim","text":"Schäfer, J.L. Strimmer, K. (2005), shrinkage approach large-scale covariance matrix estimation implications functional genomics, Statistical Applications Genetics Molecular Biology, 4, 1","code":""},{"path":[]},{"path":"https://danigiro.github.io/FoReco/reference/teboot.html","id":null,"dir":"Reference","previous_headings":"","what":"Temporal joint block bootstrap — teboot","title":"Temporal joint block bootstrap — teboot","text":"Joint block bootstrap generating probabilistic base forecasts take account correlation different temporal aggregation orders (Girolimetto et al. 2023).","code":""},{"path":"https://danigiro.github.io/FoReco/reference/teboot.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Temporal joint block bootstrap — teboot","text":"","code":"teboot(model_list, boot_size, agg_order, block_size = 1, seed = NULL)"},{"path":"https://danigiro.github.io/FoReco/reference/teboot.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Temporal joint block bootstrap — teboot","text":"model_list list \\((k^\\ast+m)\\) base forecasts models ordered lowest frequency (temporally aggregated) highest frequency. simulate() function model available implemented according package forecast, following mandatory parameters: object, innov, future, nsim. boot_size number bootstrap replicates. agg_order Highest available sampling frequency per seasonal cycle (max. order temporal aggregation, \\(m\\)), vector representing subset \\(p\\) factors \\(m\\). block_size Block size bootstrap, typically equivalent forecast horizon temporally aggregated series. seed integer seed.","code":""},{"path":"https://danigiro.github.io/FoReco/reference/teboot.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Temporal joint block bootstrap — teboot","text":"list two elements: seed used sample errors (\\(\\text{boot\\_size}\\times (k^\\ast+m)\\text{block\\_size}\\)) matrix.","code":""},{"path":"https://danigiro.github.io/FoReco/reference/teboot.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Temporal joint block bootstrap — teboot","text":"Girolimetto, D., Athanasopoulos, G., Di Fonzo, T. Hyndman, R.J. (2023), Cross-temporal probabilistic forecast reconciliation: Methodological practical issues. International Journal Forecasting, press. doi:10.1016/j.ijforecast.2023. 10.003","code":""},{"path":[]},{"path":"https://danigiro.github.io/FoReco/reference/tebu.html","id":null,"dir":"Reference","previous_headings":"","what":"Temporal bottom-up reconciliation — tebu","title":"Temporal bottom-up reconciliation — tebu","text":"Temporal bottom-reconciled forecasts temporal aggregation level computed appropriate aggregation high-frequency base forecasts, \\(\\widehat{\\mathbf{x}}^{[1]}\\): $$\\widetilde{\\mathbf{x}} = \\mathbf{S}_{te}\\widehat{\\mathbf{x}}^{[1]},$$ \\(\\mathbf{S}_{te}\\) temporal structural matrix.","code":""},{"path":"https://danigiro.github.io/FoReco/reference/tebu.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Temporal bottom-up reconciliation — tebu","text":"","code":"tebu(base, agg_order, tew = \"sum\", sntz = FALSE)"},{"path":"https://danigiro.github.io/FoReco/reference/tebu.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Temporal bottom-up reconciliation — tebu","text":"base (\\(hm \\times 1\\)) numeric vector containing high-frequency base forecasts; \\(m\\) max. temporal aggregation order, \\(h\\) forecast horizon lowest frequency time series. agg_order Highest available sampling frequency per seasonal cycle (max. order temporal aggregation, \\(m\\)), vector representing subset \\(p\\) factors \\(m\\). tew string specifying type temporal aggregation. Options include: \"sum\" (simple summation, default), \"avg\" (average), \"first\" (first value period), \"last\" (last value period). sntz TRUE, negative base forecasts set zero applying bottom-.","code":""},{"path":"https://danigiro.github.io/FoReco/reference/tebu.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Temporal bottom-up reconciliation — tebu","text":"(\\(h(k^\\ast+m) \\times 1\\)) numeric vector temporal reconciled forecasts.","code":""},{"path":[]},{"path":"https://danigiro.github.io/FoReco/reference/tebu.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Temporal bottom-up reconciliation — tebu","text":"","code":"set.seed(123) # (4 x 1) high frequency base forecasts vector (simulated), # agg_order = 4 (annual-quarterly) hfts <- rnorm(4, 5)  reco <- tebu(base = hfts, agg_order = 4)  # Non negative reconciliation hfts[4] <- -hfts[4] # Making negative one of the quarterly base forecasts nnreco <- tebu(base = hfts, agg_order = 4, sntz = TRUE)"},{"path":"https://danigiro.github.io/FoReco/reference/tecov.html","id":null,"dir":"Reference","previous_headings":"","what":"Temporal covariance matrix approximation — tecov","title":"Temporal covariance matrix approximation — tecov","text":"function provides approximation temporal base forecasts errors covariance matrix using different reconciliation methods (see Di Fonzo Girolimetto, 2023).","code":""},{"path":"https://danigiro.github.io/FoReco/reference/tecov.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Temporal covariance matrix approximation — tecov","text":"","code":"tecov(comb, agg_order = NULL, res = NULL, tew = \"sum\",       mse = TRUE, shrink_fun = shrink_estim, ...)"},{"path":"https://danigiro.github.io/FoReco/reference/tecov.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Temporal covariance matrix approximation — tecov","text":"comb string specifying reconciliation method. Ordinary least squares: \"ols\" (default) - identity error covariance. Weighted least squares: \"str\" - structural variances. \"wlsh\" - hierarchy variances (uses res). \"wlsv\" - series variances (uses res). Generalized least squares (uses res): \"acov\" - series auto-covariance. \"strar1\" - structural Markov covariance. \"sar1\" - series Markov covariance. \"har1\" - hierarchy Markov covariance. \"shr\"/\"sam\" - shrunk/sample covariance. agg_order Highest available sampling frequency per seasonal cycle (max. order temporal aggregation, \\(m\\)), vector representing subset \\(p\\) factors \\(m\\). res (\\(N(k^\\ast+m) \\times 1\\)) optional numeric vector containing -sample residuals temporal frequencies ordered lowest frequency highest frequency. vector used compute come covariance matrices. tew string specifying type temporal aggregation. Options include: \"sum\" (simple summation, default), \"avg\" (average), \"first\" (first value period), \"last\" (last value period). mse TRUE (default) residuals used compute covariance matrix mean-corrected. shrink_fun Shrinkage function covariance matrix, shrink_estim (default) ... used.","code":""},{"path":"https://danigiro.github.io/FoReco/reference/tecov.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Temporal covariance matrix approximation — tecov","text":"(\\((k^\\ast+m) \\times (k^\\ast+m)\\)) symmetric matrix.","code":""},{"path":"https://danigiro.github.io/FoReco/reference/tecov.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Temporal covariance matrix approximation — tecov","text":"Di Fonzo, T. Girolimetto, D. (2023), Cross-temporal forecast reconciliation: Optimal combination method heuristic alternatives, International Journal Forecasting, 39, 1, 39-57. doi:10.1016/j.ijforecast.2021.08.004","code":""},{"path":[]},{"path":"https://danigiro.github.io/FoReco/reference/tecov.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Temporal covariance matrix approximation — tecov","text":"","code":"# (7 x 70) in-sample residuals matrix (simulated), agg_order = 4 res <- rnorm(70)  cov1 <- tecov(\"ols\", agg_order = 4)                 # OLS methods cov2 <- tecov(\"str\", agg_order = 4)                 # STRC methods cov3 <- tecov(\"wlsv\", agg_order = 4, res = res)     # WLSv methods cov4 <- tecov(\"wlsh\", agg_order = 4, res = res)     # WLSh methods cov5 <- tecov(\"acov\", agg_order = 4, res = res)     # ACOV methods cov6 <- tecov(\"strar1\", agg_order = 4, res = res)   # STRAR1 methods cov7 <- tecov(\"har1\", agg_order = 4, res = res)     # HAR1 methods cov8 <- tecov(\"sar1\", agg_order = 4, res = res)     # SAR1 methods cov9 <- tecov(\"shr\", agg_order = 4, res = res)      # SHR methods cov10 <- tecov(\"sam\", agg_order = 4, res = res)     # SAM methods  # Custom covariance matrix tecov.ols2 <- function(comb, x) diag(x) tecov(comb = \"ols2\", x = 7) # == tecov(\"ols\", agg_order = 4) #>      [,1] [,2] [,3] [,4] [,5] [,6] [,7] #> [1,]    1    0    0    0    0    0    0 #> [2,]    0    1    0    0    0    0    0 #> [3,]    0    0    1    0    0    0    0 #> [4,]    0    0    0    1    0    0    0 #> [5,]    0    0    0    0    1    0    0 #> [6,]    0    0    0    0    0    1    0 #> [7,]    0    0    0    0    0    0    1"},{"path":"https://danigiro.github.io/FoReco/reference/telcc.html","id":null,"dir":"Reference","previous_headings":"","what":"Level conditional coherent reconciliation for temporal hierarchies — telcc","title":"Level conditional coherent reconciliation for temporal hierarchies — telcc","text":"function implements forecast reconciliation procedure inspired original proposal Hollyman et al. (2021) temporal hierarchies. Level conditional coherent reconciled forecasts conditional (.e., constrained ) base forecasts specific upper level hierarchy (exogenous constraints). also allows handling linear constraints linking variables endogenously (Di Fonzo Girolimetto, 2022). function can calculate Combined Conditional Coherent (CCC) forecasts simple averages Level-Conditional Coherent (LCC) bottom-reconciled forecasts, either endogenous exogenous constraints.","code":""},{"path":"https://danigiro.github.io/FoReco/reference/telcc.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Level conditional coherent reconciliation for temporal hierarchies — telcc","text":"","code":"telcc(base, agg_order, comb = \"ols\", res = NULL, CCC = TRUE,       const = \"exogenous\", hfts = NULL, tew = \"sum\",       approach = \"proj\", nn = NULL, settings = NULL, ...)"},{"path":"https://danigiro.github.io/FoReco/reference/telcc.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Level conditional coherent reconciliation for temporal hierarchies — telcc","text":"base (\\(h(k^\\ast + m) \\times 1\\)) numeric vector containing base forecasts reconciled ordered lowest frequency highest frequency; \\(m\\) max aggregation order, \\(k^\\ast\\) sum (subset ) (\\(p-1\\)) factors \\(m\\), excluding \\(m\\), \\(h\\) forecast horizon lowest frequency time series. agg_order Highest available sampling frequency per seasonal cycle (max. order temporal aggregation, \\(m\\)), vector representing subset \\(p\\) factors \\(m\\). comb string specifying reconciliation method. complete list, see tecov. res (\\(N(k^\\ast+m) \\times 1\\)) optional numeric vector containing -sample residuals temporal frequencies ordered lowest frequency highest frequency. vector used compute come covariance matrices. CCC logical value indicating whether Combined Conditional Coherent reconciled forecasts reconciliation include bottom-forecasts (TRUE, default), . const string specifying reconciliation constraints: \"exogenous\" (default): Fixes top level sub-hierarchy. \"endogenous\": Coherently revises top bottom levels. hfts (\\(mh \\times 1\\)) numeric vector containing high frequency base forecasts defined user. parameter can omitted base forecasts base used (see Di Fonzo Girolimetto, 2024). tew string specifying type temporal aggregation. Options include: \"sum\" (simple summation, default), \"avg\" (average), \"first\" (first value period), \"last\" (last value period). approach string specifying approach used compute reconciled forecasts. Options include: \"proj\" (default): Projection approach according Byron (1978, 1979). \"strc\": Structural approach proposed Hyndman et al. (2011). \"proj_osqp\": Numerical solution using osqp projection approach. \"strc_osqp\": Numerical solution using osqp structural approach. nn string specifying algorithm compute non-negative reconciled forecasts: \"osqp\": quadratic programming optimization (osqp solver). \"sntz\": heuristic \"set-negative--zero\" (Di Fonzo Girolimetto, 2023). settings object class osqpSettings specifying settings osqp solver. details, refer osqp documentation (Stellato et al., 2020). ... Arguments passed tecov mse TRUE (default) residuals used compute covariance matrix mean-corrected. shrink_fun Shrinkage function covariance matrix, shrink_estim (default)","code":""},{"path":"https://danigiro.github.io/FoReco/reference/telcc.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Level conditional coherent reconciliation for temporal hierarchies — telcc","text":"(\\(h(k^\\ast+m) \\times 1\\)) numeric vector temporal reconciled forecasts.","code":""},{"path":"https://danigiro.github.io/FoReco/reference/telcc.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Level conditional coherent reconciliation for temporal hierarchies — telcc","text":"Byron, R.P. (1978), estimation large social account matrices, Journal Royal Statistical Society, Series , 141, 3, 359-367. doi:10.2307/2344807 Byron, R.P. (1979), Corrigenda: estimation large social account matrices, Journal Royal Statistical Society, Series , 142(3), 405. doi:10.2307/2982515 Di Fonzo, T. Girolimetto, D. (2024), Forecast combination-based forecast reconciliation: Insights extensions, International Journal Forecasting, 40(2), 490–514. doi:10.1016/j.ijforecast.2022.07.001 Di Fonzo, T. Girolimetto, D. (2023b) Spatio-temporal reconciliation solar forecasts. Solar Energy 251, 13–29. doi:10.1016/j.solener.2023.01.003 Hyndman, R.J., Ahmed, R.., Athanasopoulos, G. Shang, H.L. (2011), Optimal combination forecasts hierarchical time series, Computational Statistics & Data Analysis, 55, 9, 2579-2589. doi:10.1016/j.csda.2011.03.006 Hollyman, R., Petropoulos, F. Tipping, M.E. (2021), Understanding forecast reconciliation. European Journal Operational Research, 294, 149–160. doi:10.1016/j.ejor.2021.01.017 Stellato, B., Banjac, G., Goulart, P., Bemporad, . Boyd, S. (2020), OSQP: Operator Splitting solver Quadratic Programs, Mathematical Programming Computation, 12, 4, 637-672. doi:10.1007/s12532-020-00179-2","code":""},{"path":[]},{"path":"https://danigiro.github.io/FoReco/reference/telcc.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Level conditional coherent reconciliation for temporal hierarchies — telcc","text":"","code":"set.seed(123) # (7 x 1) base forecasts vector (simulated), agg_order = 4 base <- rnorm(7, rep(c(20, 10, 5), c(1, 2, 4))) # (70 x 1) in-sample residuals vector (simulated) res <- rnorm(70) # (4 x 1) Naive high frequency base forecasts vector: all forecasts are set equal to 2.5 naive <- rep(2.5, 4)  ## EXOGENOUS CONSTRAINTS # Level Conditional Coherent (LCC) reconciled forecasts exo_LC <- telcc(base = base, agg_order = 4, comb = \"wlsh\", hfts = naive,                 res = res, nodes = \"auto\", CCC = FALSE)  # Combined Conditional Coherent (CCC) reconciled forecasts exo_CCC <- telcc(base = base, agg_order = 4, comb = \"wlsh\", hfts = naive,                  res = res, nodes = \"auto\", CCC = TRUE)  # Results detailed by level: info_exo <- recoinfo(exo_CCC, verbose = FALSE) # info_exo$lcc  ## ENDOGENOUS CONSTRAINTS # Level Conditional Coherent (LCC) reconciled forecasts endo_LC <- telcc(base = base, agg_order = 4, comb = \"wlsh\", res = res,                  nodes = \"auto\", CCC = FALSE, const = \"endogenous\")  # Combined Conditional Coherent (CCC) reconciled forecasts endo_CCC <- telcc(base = base, agg_order = 4, comb = \"wlsh\", res = res,                   nodes = \"auto\", CCC = TRUE, const = \"endogenous\")  # Results detailed by level: info_endo <- recoinfo(endo_CCC, verbose = FALSE) # info_endo$lcc"},{"path":"https://danigiro.github.io/FoReco/reference/temo.html","id":null,"dir":"Reference","previous_headings":"","what":"Temporal middle-out reconciliation — temo","title":"Temporal middle-out reconciliation — temo","text":"middle-forecast reconciliation temporal hierarchies combines top-(tetd) bottom-(tebu) methods. Given base forecasts intermediate temporal aggregation order \\(k\\), performs top-approach aggregation orders \\(<k\\); bottom-approach aggregation orders \\(>k\\).","code":""},{"path":"https://danigiro.github.io/FoReco/reference/temo.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Temporal middle-out reconciliation — temo","text":"","code":"temo(base, agg_order, order = max(agg_order), weights, tew = \"sum\",      normalize = TRUE)"},{"path":"https://danigiro.github.io/FoReco/reference/temo.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Temporal middle-out reconciliation — temo","text":"base (\\(hk \\times 1\\)) numeric vector containing temporal aggregated base forecasts order \\(k\\); \\(k\\) aggregation order (factor \\(m\\), \\(1<k<m\\)), \\(m\\) max aggregation order, \\(h\\) forecast horizon lowest frequency time series. agg_order Highest available sampling frequency per seasonal cycle (max. order temporal aggregation, \\(m\\)), vector representing subset \\(p\\) factors \\(m\\). order intermediate fixed aggregation order \\(k\\). weights (\\(hm \\times 1\\)) numeric vector containing proportions high-frequency time series; \\(m\\) max aggregation order, \\(h\\) forecast horizon lowest frequency time series. tew string specifying type temporal aggregation. Options include: \"sum\" (simple summation, default), \"avg\" (average), \"first\" (first value period), \"last\" (last value period). normalize TRUE (default), weights sum 1.","code":""},{"path":"https://danigiro.github.io/FoReco/reference/temo.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Temporal middle-out reconciliation — temo","text":"(\\(h(k^\\ast+m) \\times 1\\)) numeric vector temporal reconciled forecasts.","code":""},{"path":[]},{"path":"https://danigiro.github.io/FoReco/reference/temo.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Temporal middle-out reconciliation — temo","text":"","code":"set.seed(123) # (6 x 1) base forecasts vector (simulated), forecast horizon = 3 # and intermediate aggregation order k = 2 (max agg order = 4) basek2 <- rnorm(3*2, 5) # Same weights for different forecast horizons fix_weights <- runif(4) reco <- temo(base = basek2, order = 2, agg_order = 4, weights = fix_weights)  # Different weights for different forecast horizons h_weights <- runif(4*3) recoh <- temo(base = basek2, order = 2, agg_order = 4, weights = h_weights)"},{"path":"https://danigiro.github.io/FoReco/reference/teprojmat.html","id":null,"dir":"Reference","previous_headings":"","what":"Projection matrix for optimal combination temporal reconciliation — teprojmat","title":"Projection matrix for optimal combination temporal reconciliation — teprojmat","text":"function computes projection mapping matrix \\(\\mathbf{M}\\) \\(\\mathbf{G}\\), respectively, \\(\\widetilde{\\mathbf{y}} = \\mathbf{M}\\widehat{\\mathbf{y}} = \\mathbf{S}_{te}\\mathbf{G}\\widehat{\\mathbf{y}}\\), \\(\\widetilde{\\mathbf{y}}\\) vector reconciled forecasts, \\(\\widehat{\\mathbf{y}}\\) vector base forecasts, \\(\\mathbf{S}_{te}\\) temporal structural matrix, \\(\\mathbf{M} = \\mathbf{S}_{te}\\mathbf{G}\\). information regarding structure matrices, refer Girolimetto et al. (2023).","code":""},{"path":"https://danigiro.github.io/FoReco/reference/teprojmat.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Projection matrix for optimal combination temporal reconciliation — teprojmat","text":"","code":"teprojmat(agg_order, comb = \"ols\", res = NULL, mat = \"M\", tew = \"sum\", ...)"},{"path":"https://danigiro.github.io/FoReco/reference/teprojmat.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Projection matrix for optimal combination temporal reconciliation — teprojmat","text":"agg_order Highest available sampling frequency per seasonal cycle (max. order temporal aggregation, \\(m\\)), vector representing subset \\(p\\) factors \\(m\\). comb string specifying reconciliation method. complete list, see tecov. res (\\(N(k^\\ast+m) \\times 1\\)) optional numeric vector containing -sample residuals temporal frequencies ordered lowest frequency highest frequency. vector used compute come covariance matrices. mat string specifying matrix return: \"M\" (default) \\(\\mathbf{M}\\) \"G\" \\(\\mathbf{G}\\). tew string specifying type temporal aggregation. Options include: \"sum\" (simple summation, default), \"avg\" (average), \"first\" (first value period), \"last\" (last value period). ... Arguments passed tecov mse TRUE (default) residuals used compute covariance matrix mean-corrected. shrink_fun Shrinkage function covariance matrix, shrink_estim (default)","code":""},{"path":"https://danigiro.github.io/FoReco/reference/teprojmat.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Projection matrix for optimal combination temporal reconciliation — teprojmat","text":"projection matrix \\(\\mathbf{M}\\) (mat = \"M\") mapping matrix \\(\\mathbf{G}\\) (mat = \"G\").","code":""},{"path":"https://danigiro.github.io/FoReco/reference/teprojmat.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Projection matrix for optimal combination temporal reconciliation — teprojmat","text":"Girolimetto, D., Athanasopoulos, G., Di Fonzo, T. Hyndman, R.J. (2024), Cross-temporal probabilistic forecast reconciliation: Methodological practical issues. International Journal Forecasting, 40, 3, 1134-1151. doi:10.1016/j.ijforecast.2023. 10.003","code":""},{"path":[]},{"path":"https://danigiro.github.io/FoReco/reference/teprojmat.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Projection matrix for optimal combination temporal reconciliation — teprojmat","text":"","code":"# Temporal framework (annual-quarterly) Mte <- teprojmat(agg_order = 4, comb = \"ols\") Gte <- teprojmat(agg_order = 4, comb = \"ols\", mat = \"G\")"},{"path":"https://danigiro.github.io/FoReco/reference/terec.html","id":null,"dir":"Reference","previous_headings":"","what":"Optimal combination temporal reconciliation — terec","title":"Optimal combination temporal reconciliation — terec","text":"function performs forecast reconciliation single time series using temporal hierarchies (Athanasopoulos et al., 2017, Nystrup et al., 2020). reconciled forecasts can computed using either projection approach (Byron, 1978, 1979) equivalent structural approach Hyndman et al. (2011). Non-negative (Di Fonzo Girolimetto, 2023) immutable reconciled forecasts can considered.","code":""},{"path":"https://danigiro.github.io/FoReco/reference/terec.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Optimal combination temporal reconciliation — terec","text":"","code":"terec(base, agg_order, comb = \"ols\", res = NULL, tew = \"sum\",       approach = \"proj\", nn = NULL, settings = NULL, bounds = NULL,       immutable = NULL, ...)"},{"path":"https://danigiro.github.io/FoReco/reference/terec.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Optimal combination temporal reconciliation — terec","text":"base (\\(h(k^\\ast + m) \\times 1\\)) numeric vector containing base forecasts reconciled ordered lowest frequency highest frequency; \\(m\\) max aggregation order, \\(k^\\ast\\) sum (subset ) (\\(p-1\\)) factors \\(m\\), excluding \\(m\\), \\(h\\) forecast horizon lowest frequency time series. agg_order Highest available sampling frequency per seasonal cycle (max. order temporal aggregation, \\(m\\)), vector representing subset \\(p\\) factors \\(m\\). comb string specifying reconciliation method. complete list, see tecov. res (\\(N(k^\\ast+m) \\times 1\\)) optional numeric vector containing -sample residuals temporal frequencies ordered lowest frequency highest frequency. vector used compute come covariance matrices. tew string specifying type temporal aggregation. Options include: \"sum\" (simple summation, default), \"avg\" (average), \"first\" (first value period), \"last\" (last value period). approach string specifying approach used compute reconciled forecasts. Options include: \"proj\" (default): Projection approach according Byron (1978, 1979). \"strc\": Structural approach proposed Hyndman et al. (2011). \"proj_osqp\": Numerical solution using osqp projection approach. \"strc_osqp\": Numerical solution using osqp structural approach. nn string specifying algorithm compute non-negative reconciled forecasts: \"osqp\": quadratic programming optimization (osqp solver). \"sntz\": heuristic \"set-negative--zero\" (Di Fonzo Girolimetto, 2023). settings object class osqpSettings specifying settings osqp solver. details, refer osqp documentation (Stellato et al., 2020). bounds (\\((k^\\ast + m) \\times 2\\)) numeric matrix specifying temporal bounds. first column represents lower bound, second column represents upper bound. immutable matrix two columns (\\(k,j\\)), Column 1 Denotes temporal aggregation order (\\(k = m,\\dots,1\\)). Column 2 Indicates temporal forecast horizon (\\(j = 1,\\dots,m/k\\)). example, working quarterly time series: t(c(4, 1)) - Fix one step ahead annual forecast. t(c(1, 2)) - Fix two step ahead quarterly forecast. ... Arguments passed tecov mse TRUE (default) residuals used compute covariance matrix mean-corrected. shrink_fun Shrinkage function covariance matrix, shrink_estim (default)","code":""},{"path":"https://danigiro.github.io/FoReco/reference/terec.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Optimal combination temporal reconciliation — terec","text":"(\\(h(k^\\ast+m) \\times 1\\)) numeric vector temporal reconciled forecasts.","code":""},{"path":"https://danigiro.github.io/FoReco/reference/terec.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Optimal combination temporal reconciliation — terec","text":"Athanasopoulos, G., Hyndman, R.J., Kourentzes, N. Petropoulos, F. (2017), Forecasting Temporal Hierarchies, European Journal Operational Research, 262, 1, 60-74. doi:10.1016/j.ejor.2017.02.046 Byron, R.P. (1978), estimation large social account matrices, Journal Royal Statistical Society, Series , 141, 3, 359-367. doi:10.2307/2344807 Byron, R.P. (1979), Corrigenda: estimation large social account matrices, Journal Royal Statistical Society, Series , 142(3), 405. doi:10.2307/2982515 Di Fonzo, T. Girolimetto, D. (2023), Spatio-temporal reconciliation solar forecasts, Solar Energy, 251, 13–29. doi:10.1016/j.solener.2023.01.003 Hyndman, R.J., Ahmed, R.., Athanasopoulos, G. Shang, H.L. (2011), Optimal combination forecasts hierarchical time series, Computational Statistics & Data Analysis, 55, 9, 2579-2589. doi:10.1016/j.csda.2011.03.006 Nystrup, P.,  Lindström, E., Pinson, P. Madsen, H. (2020), Temporal hierarchies autocorrelation load forecasting, European Journal Operational Research, 280, 1, 876-888. doi:10.1016/j.ejor.2019.07.061 Stellato, B., Banjac, G., Goulart, P., Bemporad, . Boyd, S. (2020), OSQP: Operator Splitting solver Quadratic Programs, Mathematical Programming Computation, 12, 4, 637-672. doi:10.1007/s12532-020-00179-2","code":""},{"path":[]},{"path":"https://danigiro.github.io/FoReco/reference/terec.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Optimal combination temporal reconciliation — terec","text":"","code":"set.seed(123) # (7 x 1) base forecasts vector (simulated), m = 4 base <- rnorm(7, rep(c(20, 10, 5), c(1, 2, 4))) # (70 x 1) in-sample residuals vector (simulated) res <- rnorm(70)  m <- 4 # from quarterly to annual temporal aggregation reco <- terec(base = base, agg_order = m, comb = \"wlsv\", res = res)  # Immutable reconciled forecast # E.g. fix all the quarterly forecasts imm_q <- expand.grid(k = 1, j = 1:4) immreco <- terec(base = base, agg_order = m, comb = \"wlsv\",                  res = res, immutable = imm_q)  # Non negative reconciliation base[7] <- -base[7] # Making negative one of the quarterly base forecasts nnreco <- terec(base = base, agg_order = m, comb = \"wlsv\",                 res = res, nn = \"osqp\") recoinfo(nnreco, verbose = FALSE)$info #>     obj_val   run_time iter      pri_res status status_polish #> 1 -421.8914 4.2499e-05   25 8.587788e-16      1             1"},{"path":"https://danigiro.github.io/FoReco/reference/tetd.html","id":null,"dir":"Reference","previous_headings":"","what":"Temporal top-down reconciliation — tetd","title":"Temporal top-down reconciliation — tetd","text":"Top-forecast reconciliation univariate time series, forecast aggregated temporal level disaggregated according proportional scheme (weights). Besides fulfilling aggregation constraint, top-reconciled forecasts respect two main properties: top-level value remains unchanged; bottom time series reconciled forecasts non-negative.","code":""},{"path":"https://danigiro.github.io/FoReco/reference/tetd.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Temporal top-down reconciliation — tetd","text":"","code":"tetd(base, agg_order, weights, tew = \"sum\", normalize = TRUE)"},{"path":"https://danigiro.github.io/FoReco/reference/tetd.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Temporal top-down reconciliation — tetd","text":"base (\\(hm \\times 1\\)) numeric vector containing temporal aggregated base forecasts order \\(m\\); \\(m\\) max aggregation order, \\(h\\) forecast horizon lowest frequency time series. agg_order Highest available sampling frequency per seasonal cycle (max. order temporal aggregation, \\(m\\)), vector representing subset \\(p\\) factors \\(m\\). weights (\\(hm \\times 1\\)) numeric vector containing proportions high-frequency time series; \\(m\\) max aggregation order, \\(h\\) forecast horizon lowest frequency time series. tew string specifying type temporal aggregation. Options include: \"sum\" (simple summation, default), \"avg\" (average), \"first\" (first value period), \"last\" (last value period). normalize TRUE (default), weights sum 1.","code":""},{"path":"https://danigiro.github.io/FoReco/reference/tetd.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Temporal top-down reconciliation — tetd","text":"(\\(h(k^\\ast+m) \\times 1\\)) numeric vector temporal reconciled forecasts.","code":""},{"path":[]},{"path":"https://danigiro.github.io/FoReco/reference/tetd.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Temporal top-down reconciliation — tetd","text":"","code":"set.seed(123) # (2 x 1) top base forecasts vector (simulated), forecast horizon = 2 topf <- rnorm(2, 10) # Same weights for different forecast horizons fix_weights <- runif(4) reco <- tetd(base = topf, agg_order = 4, weights = fix_weights)  # Different weights for different forecast horizons h_weights <- runif(4*2) recoh <- tetd(base = topf, agg_order = 4, weights = h_weights)"},{"path":"https://danigiro.github.io/FoReco/reference/tetools.html","id":null,"dir":"Reference","previous_headings":"","what":"Temporal reconciliation tools — tetools","title":"Temporal reconciliation tools — tetools","text":"useful tools forecast reconciliation temporal hierarchies.","code":""},{"path":"https://danigiro.github.io/FoReco/reference/tetools.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Temporal reconciliation tools — tetools","text":"","code":"tetools(agg_order, fh = 1, tew = \"sum\", sparse = TRUE)"},{"path":"https://danigiro.github.io/FoReco/reference/tetools.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Temporal reconciliation tools — tetools","text":"agg_order Highest available sampling frequency per seasonal cycle (max. order temporal aggregation, \\(m\\)), vector representing subset \\(p\\) factors \\(m\\). fh Forecast horizon lowest frequency (temporally aggregated) time series (default 1). tew string specifying type temporal aggregation. Options include: \"sum\" (simple summation, default), \"avg\" (average), \"first\" (first value period), \"last\" (last value period). sparse Option return sparse matrices (default TRUE).","code":""},{"path":"https://danigiro.github.io/FoReco/reference/tetools.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Temporal reconciliation tools — tetools","text":"list five elements: dim vector containing information maximum aggregation order (m), number factor (p), partial (ks) total sum (kt) factors. set vector temporal aggregation orders (decreasing order). agg_mat temporal linear combination aggregation matrix. strc_mat temporal structural matrix. cons_mat temporal zero constraints matrix.","code":""},{"path":[]},{"path":"https://danigiro.github.io/FoReco/reference/tetools.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Temporal reconciliation tools — tetools","text":"","code":"# Temporal framework (quarterly data) obj <- tetools(agg_order = 4, sparse = FALSE)"},{"path":"https://danigiro.github.io/FoReco/reference/unbalance_hierarchy.html","id":null,"dir":"Reference","previous_headings":"","what":"Aggregation matrix of a balanced hierarchy in (possibly) unbalanced form — unbalance_hierarchy","title":"Aggregation matrix of a balanced hierarchy in (possibly) unbalanced form — unbalance_hierarchy","text":"hierarchy \\(L\\) upper levels said balanced variable level \\(l\\) least one child level \\(l+1\\). hold, hierarchy unbalanced. function transforms aggregation matrix balanced hierarchy aggregation matrix unbalanced one, removing possible duplicated series.","code":""},{"path":"https://danigiro.github.io/FoReco/reference/unbalance_hierarchy.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Aggregation matrix of a balanced hierarchy in (possibly) unbalanced form — unbalance_hierarchy","text":"","code":"unbalance_hierarchy(agg_mat, more_info = FALSE, sparse = TRUE)"},{"path":"https://danigiro.github.io/FoReco/reference/unbalance_hierarchy.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Aggregation matrix of a balanced hierarchy in (possibly) unbalanced form — unbalance_hierarchy","text":"agg_mat (\\(n_a \\times n_b\\)) numeric matrix representing cross-sectional aggregation matrix. maps \\(n_b\\) bottom-level (free) variables \\(n_a\\) upper (constrained) variables. more_info TRUE, returns aggregation matrix unbalanced hierarchy. Default FALSE. sparse Option return sparse matrices (default TRUE).","code":""},{"path":"https://danigiro.github.io/FoReco/reference/unbalance_hierarchy.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Aggregation matrix of a balanced hierarchy in (possibly) unbalanced form — unbalance_hierarchy","text":"list containing four elements (more_info = TRUE): ubm aggregation matrix unbalanced hierarchy. agg_mat input matrix. idrm identification number duplicated variables (row numbers aggregation matrix agg_mat). id identification number variable balanced hierarchy. may contains duplicated values.","code":""},{"path":[]},{"path":"https://danigiro.github.io/FoReco/reference/unbalance_hierarchy.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Aggregation matrix of a balanced hierarchy in (possibly) unbalanced form — unbalance_hierarchy","text":"","code":"#     Balanced     ->     Unbalanced #        T                    T #    |-------|            |-------| #    A       B            A       | #  |---|     |          |---|     | # AA   AB    BA        AA   AB    BA A <- matrix(c(1, 1, 1,               1, 1, 0,               0, 0, 1), 3, byrow = TRUE) obj <- unbalance_hierarchy(agg_mat = A) obj #> 2 x 3 sparse Matrix of class \"dgCMatrix\" #>            #> [1,] 1 1 1 #> [2,] 1 1 ."},{"path":"https://danigiro.github.io/FoReco/reference/vndata.html","id":null,"dir":"Reference","previous_headings":"","what":"Australian Tourism Demand dataset — vndata","title":"Australian Tourism Demand dataset — vndata","text":"Australian Tourism Demand dataset (Wickramasuriya et al. 2019) measures number nights Australians spent away home. includes 228 monthly observations Visitor Nights (VNs) January 1998 December 2016, cross-sectional grouped structure based geographic hierarchy crossed purpose travel. geographic hierarchy comprises 7 states, 27 zones, 76 regions, total 111 nested geographic divisions. Six zones formed single region, resulting 105 unique nodes hierarchy. purpose travel comprises four categories: holiday, visiting friends relatives, business, . avoid redundancies (Girolimetto et al. 2023), 24 nodes (6 zones formed single region) considered, resulting unbalanced hierarchy 525 (304 bottom 221 upper time series) unique nodes instead theoretical 555 duplicated nodes.","code":""},{"path":"https://danigiro.github.io/FoReco/reference/vndata.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Australian Tourism Demand dataset — vndata","text":"","code":"# 525 time series of the Australian Tourism Demand dataset vndata  # aggregation matrix vnaggmat"},{"path":"https://danigiro.github.io/FoReco/reference/vndata.html","id":"format","dir":"Reference","previous_headings":"","what":"Format","title":"Australian Tourism Demand dataset — vndata","text":"vndata \\((228 \\times 525)\\) ts object, corresponding 525 time series Australian Tourism Demand dataset (1998:01-2016:12). vnaggmat \\((221 \\times 304)\\) aggregation matrix.","code":""},{"path":"https://danigiro.github.io/FoReco/reference/vndata.html","id":"source","dir":"Reference","previous_headings":"","what":"Source","title":"Australian Tourism Demand dataset — vndata","text":"https://robjhyndman.com/publications/mint/","code":""},{"path":"https://danigiro.github.io/FoReco/reference/vndata.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Australian Tourism Demand dataset — vndata","text":"Girolimetto, D., Athanasopoulos, G., Di Fonzo, T. Hyndman, R.J. (2024), Cross-temporal probabilistic forecast reconciliation: Methodological practical issues. International Journal Forecasting,  40, 3, 1134-1151. doi:10.1016/j.ijforecast.2023. 10.003 Wickramasuriya, S.L., Athanasopoulos, G. Hyndman, R.J. (2019), Optimal forecast reconciliation hierarchical grouped time series trace minimization, Journal American Statistical Association, 114, 526, 804-819. doi:10.1080/ 01621459.2018.1448825","code":""},{"path":"https://danigiro.github.io/FoReco/news/index.html","id":"foreco-100","dir":"Changelog","previous_headings":"","what":"FoReco 1.0.0","title":"FoReco 1.0.0","text":"Note – latest release FoReco introduces significant changes function notation adds several new features. major update, FoReco 1.0, compatible previous versions due substantial changes made package’s core structure. previous version available Github (docs). Due significant changes FoReco 1.0, users advised carefully review updated documentation examples using new version. latest documentation release notes available danigiro.github.io/FoReco/ Updated Function Notation: functions related cross-sectional, temporal, cross-temporal frameworks now use prefixes cs, te, ct, respectively. example, optimal combination reconciliation functions now csrec(), terec(), ctrec(). Simplified Function Outputs: Reconciliation functions now return matrices. Additional information can accessed using attr(., \"FoReco\") recoinfo() function. New Datasets: Two new datasets, itagdp (Italian Quarterly National Accounts) vndata (Australian Tourism Demand), included along respective aggregation constraint matrices. Classic Approach: middle-approach (csmo(), temo(), ctmo()) implemented alongside classic bottom-(csbu(), tebu(), ctbu()) top-(cstd(), tetd(), cttd()) methods. Level Conditional Coherent Reconciliation: Level conditional coherent reconciliation now available constraints: cslcc() (cross-sectional), telcc() (temporal), ctlcc() (cross-temporal). Immutable reconciliation: immutable() parameter added reconciliation functions (csrec(), terec(), ctrec()) prevent base forecasts modified structural (approach='strc') zero-constrained (approach='proj') approach. Balanced unbalanced hierarchy: added balance_hierarchy() unbalance_hierarchy() dealing balanced unbalanced hierarchies. Projection Matrix Functions: Functions csprojmat(), teprojmat(), ctprojmat() added obtain projection matrices. Covariance Matrix Functions: Functions cscov(), tecov(), ctcov() added obtain covariance matrices. Function Renaming: Several functions renamed improve consistency clarity Cmatrix() -> df2aggmat() hts_tools() -> cstools() thf_tools() -> tetools() ctf_tools() -> cttools() agg_ts() -> aggts() residuals_matrix() -> res2matrix() boot_cs() -> csboot() boot_te() -> teboot() boot_ct() -> ctboot() htsrec() -> csrec() thfrec() -> terec() octrec() -> ctrec() lccrec() -> cslcc()","code":""},{"path":"https://danigiro.github.io/FoReco/news/index.html","id":"foreco-026","dir":"Changelog","previous_headings":"","what":"FoReco 0.2.6","title":"FoReco 0.2.6","text":"CRAN release: 2023-05-16","code":""},{"path":"https://danigiro.github.io/FoReco/news/index.html","id":"major-changes-probabilistic-forecast-reconciliation-0-2-6","dir":"Changelog","previous_headings":"","what":"FoReco 0.2.6","title":"FoReco 0.2.6","text":"Added boot_cs(), boot_te() boot_ct() draw samples , respectively, cross-sectional, temporal cross-temporal joint (block) bootstrap.","code":""},{"path":"https://danigiro.github.io/FoReco/news/index.html","id":"minor-changes-0-2-6","dir":"Changelog","previous_headings":"","what":"FoReco 0.2.6","title":"FoReco 0.2.6","text":"Fixed deprecation warnings Matrix (v. 1.5-0); Improved docs bug fixes; Fixed ctbu() inputs; Added FoReco2matrix() transform FoReco forecasts input output list matrix/vector class; Added agg_ts(): non-overlapping temporal aggregation time series according specific aggregation order. Added arrange_hres() residuals_matrix() functions arrange residuals covariance matrix Gaussianity;","code":""},{"path":"https://danigiro.github.io/FoReco/news/index.html","id":"foreco-025","dir":"Changelog","previous_headings":"","what":"FoReco 0.2.5","title":"FoReco 0.2.5","text":"CRAN release: 2022-07-04","code":""},{"path":"https://danigiro.github.io/FoReco/news/index.html","id":"minor-changes-0-2-5","dir":"Changelog","previous_headings":"","what":"FoReco 0.2.5","title":"FoReco 0.2.5","text":"Fixed negative reconciliation “sntz” octrec(); Fixed documentation.","code":""},{"path":"https://danigiro.github.io/FoReco/news/index.html","id":"foreco-024","dir":"Changelog","previous_headings":"","what":"FoReco 0.2.4","title":"FoReco 0.2.4","text":"CRAN release: 2022-06-16","code":""},{"path":"https://danigiro.github.io/FoReco/news/index.html","id":"major-changes-0-2-4","dir":"Changelog","previous_headings":"","what":"FoReco 0.2.4","title":"FoReco 0.2.4","text":"Added lcmat() function.","code":""},{"path":"https://danigiro.github.io/FoReco/news/index.html","id":"minor-changes-0-2-4","dir":"Changelog","previous_headings":"","what":"FoReco 0.2.4","title":"FoReco 0.2.4","text":"Fixed BU approach number columns basef equal number bottom time series htsrec(); Fixed score_index(); Fixed bounds param type = \"S\" htsrec(), thfrec() octrec(); Add possibility fix base forecasts v param htsrec(), thfrec() octrec() - experimental; Add two new type optimal cross-temporal reconciliation (cs_struc t_struc); Improved docs bug fixes.","code":""},{"path":"https://danigiro.github.io/FoReco/news/index.html","id":"foreco-022","dir":"Changelog","previous_headings":"","what":"FoReco 0.2.2","title":"FoReco 0.2.2","text":"CRAN release: 2022-02-17","code":""},{"path":"https://danigiro.github.io/FoReco/news/index.html","id":"minor-changes-0-2-2","dir":"Changelog","previous_headings":"","what":"FoReco 0.2.2","title":"FoReco 0.2.2","text":"Fixed documentation; Removed ut2c() srref().","code":""},{"path":"https://danigiro.github.io/FoReco/news/index.html","id":"foreco-021","dir":"Changelog","previous_headings":"","what":"FoReco 0.2.1","title":"FoReco 0.2.1","text":"CRAN release: 2021-07-23","code":""},{"path":"https://danigiro.github.io/FoReco/news/index.html","id":"minor-changes-0-2-1","dir":"Changelog","previous_headings":"","what":"FoReco 0.2.1","title":"FoReco 0.2.1","text":"Fixed bug output lccrec() (now function returns Level Conditional Coherent Combined Conditional Coherent forecasts); Fixed negative reconciliation “KAnn” keep = \"list\".","code":""},{"path":"https://danigiro.github.io/FoReco/news/index.html","id":"foreco-020","dir":"Changelog","previous_headings":"","what":"FoReco 0.2.0","title":"FoReco 0.2.0","text":"CRAN release: 2021-05-21","code":""},{"path":"https://danigiro.github.io/FoReco/news/index.html","id":"major-changes-0-2-0","dir":"Changelog","previous_headings":"","what":"FoReco 0.2.0","title":"FoReco 0.2.0","text":"’s possible use subset factors m (max. order temporal aggregation); Added possibility htsrec(), thfrec() octrec() introduce list h covariance matrices parameters W Omega, h stands forecast horizon (note thfrec() octrec() forecast horizon entire cycle); Param Sstruc avaible octrec() ctf_tools(). FoReco uses fast algorithm compute Scheck, external input needed; Modified output ctf_tools() (added Ccheck, Htcheck, Scheck, removed Cstruc, Sstruc), hts_tools() (added C) thf_tools() (added m); Added two new negative reconciliation techniques (“KAnn” “sntz”) new parameter (nn_type) htsrec(), thfrec() octrec(); Added top-reconciliation function tdrec(); Added level conditional forecast reconciliation (without -negative constraints) genuine hierarchical/grouped time series levrec() (cross-sectional, temporal cross-temporal).","code":""},{"path":"https://danigiro.github.io/FoReco/news/index.html","id":"minor-changes-0-2-0","dir":"Changelog","previous_headings":"","what":"FoReco 0.2.0","title":"FoReco 0.2.0","text":"Now octrec() also possible introduce Ω covariance matrix variant Omega parameter W variant W parameter; Updated tcsrec(), cstrec() iterec(). iterec() function maxit parameter replaced itmax, however moment maxit still supported; Now FoReco removes null rows cross-sectional aggregation matrix C warns user balanced version unbalanced hierarchy considering duplicated variables; Redesigned console output added new convergence norm default iterec() (norm parameter).","code":""},{"path":"https://danigiro.github.io/FoReco/news/index.html","id":"experimental-0-2-0","dir":"Changelog","previous_headings":"","what":"FoReco 0.2.0","title":"FoReco 0.2.0","text":"Add possibility introduce constraints bounds param htsrec(), thfrec() octrec(); Add function oct_bounds() organize bounds specific dimension (.e. cross-sectional temporal) cross-temporal framework; Added ut2c() srref() develop cross-sectional structural representation starting zero constraints kernel matrix; Added score_index() calculation multiple forecast horizons index (like 1:6) multiple cross-sectional levels forecasting experiment.","code":""},{"path":"https://danigiro.github.io/FoReco/news/index.html","id":"foreco-011","dir":"Changelog","previous_headings":"","what":"FoReco 0.1.1","title":"FoReco 0.1.1","text":"CRAN release: 2020-10-17 Minore release, fixing bugs documentation Fixed bug iterec() calculating incoherence Fixed documentation Changed contact mail (now ’s daniele.girolimetto@phd.unipd.) Corrected second section vignette “Average relative accuracy indices”","code":""},{"path":"https://danigiro.github.io/FoReco/news/index.html","id":"foreco-010","dir":"Changelog","previous_headings":"","what":"FoReco 0.1.0","title":"FoReco 0.1.0","text":"CRAN release: 2020-10-01 Release github","code":""}]
